module.exports = [
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./type')} */ module.exports = TypeError;
}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Error;
}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./eval')} */ module.exports = EvalError;
}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./range')} */ module.exports = RangeError;
}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./ref')} */ module.exports = ReferenceError;
}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./syntax')} */ module.exports = SyntaxError;
}),
"[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./uri')} */ module.exports = URIError;
}),
"[project]/node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[externals]/util [external] (util, cjs)").inspect;
}),
"[project]/node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
 ? function(O) {
    return O.__proto__; // eslint-disable-line no-proto
} : null);
function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}
var utilInspect = __turbopack_context__.r("[project]/node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js [app-route] (ecmascript)");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
};
var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
};
module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }
    if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }
    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') {
        depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }
    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === 'function' && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for(var i = 0; i < attrs.length; i++){
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) {
            s += '...';
        }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) {
            return '[]';
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) {
            return '[' + String(obj) + ']';
        }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, {
                depth: maxDepth - depth
            });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function(value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function(value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */ if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if (typeof globalThis !== 'undefined' && obj === globalThis || ("TURBOPACK compile-time value", "object") !== 'undefined' && obj === /*TURBOPACK member replacement*/ __turbopack_context__.g) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) {
            return tag + '{}';
        }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}
function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}
function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray(obj) {
    return toStr(obj) === '[object Array]' && canTrustToString(obj);
}
function isDate(obj) {
    return toStr(obj) === '[object Date]' && canTrustToString(obj);
}
function isRegExp(obj) {
    return toStr(obj) === '[object RegExp]' && canTrustToString(obj);
}
function isError(obj) {
    return toStr(obj) === '[object Error]' && canTrustToString(obj);
}
function isString(obj) {
    return toStr(obj) === '[object String]' && canTrustToString(obj);
}
function isNumber(obj) {
    return toStr(obj) === '[object Number]' && canTrustToString(obj);
}
function isBoolean(obj) {
    return toStr(obj) === '[object Boolean]' && canTrustToString(obj);
}
// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}
function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
};
function has(obj, key) {
    return hasOwn.call(obj, key);
}
function toStr(obj) {
    return objectToString.call(obj);
}
function nameOf(f) {
    if (f.name) {
        return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
        return m[1];
    }
    return null;
}
function indexOf(xs, x) {
    if (xs.indexOf) {
        return xs.indexOf(x);
    }
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) {
            return i;
        }
    }
    return -1;
}
function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}
function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}
function isElement(x) {
    if (!x || typeof x !== 'object') {
        return false;
    }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}
function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}
function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) {
        return '\\' + x;
    }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
    return 'Object(' + str + ')';
}
function weakCollectionOf(type) {
    return type + ' { ? }';
}
function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}
function singleLineValues(xs) {
    for(var i = 0; i < xs.length; i++){
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}
function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}
function indentedJoin(xs, indent) {
    if (xs.length === 0) {
        return '';
    }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}
function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for(var i = 0; i < obj.length; i++){
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for(var k = 0; k < syms.length; k++){
            symMap['$' + syms[k]] = syms[k];
        }
    }
    for(var key in obj){
        if (!has(obj, key)) {
            continue;
        } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) {
            continue;
        } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for(var j = 0; j < syms.length; j++){
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}
}),
"[project]/node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var inspect = __turbopack_context__.r("[project]/node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-route] (ecmascript)");
/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/ /** @type {import('./list.d.ts').listGetNode} */ // eslint-disable-next-line consistent-return
var listGetNode = function(list, key, isDelete) {
    /** @type {typeof list | NonNullable<(typeof list)['next']>} */ var prev = list;
    /** @type {(typeof list)['next']} */ var curr;
    // eslint-disable-next-line eqeqeq
    for(; (curr = prev.next) != null; prev = curr){
        if (curr.key === key) {
            prev.next = curr.next;
            if (!isDelete) {
                // eslint-disable-next-line no-extra-parens
                curr.next = list.next;
                list.next = curr; // eslint-disable-line no-param-reassign
            }
            return curr;
        }
    }
};
/** @type {import('./list.d.ts').listGet} */ var listGet = function(objects, key) {
    if (!objects) {
        return void undefined;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */ var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
        node.value = value;
    } else {
        // Prepend the new node to the beginning of the list
        objects.next = {
            key: key,
            next: objects.next,
            value: value
        };
    }
};
/** @type {import('./list.d.ts').listHas} */ var listHas = function(objects, key) {
    if (!objects) {
        return false;
    }
    return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */ // eslint-disable-next-line consistent-return
var listDelete = function(objects, key) {
    if (objects) {
        return listGetNode(objects, key, true);
    }
};
/** @type {import('.')} */ module.exports = function getSideChannelList() {
    /** @typedef {ReturnType<typeof getSideChannelList>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            var root = $o && $o.next;
            var deletedNode = listDelete($o, key);
            if (deletedNode && root && root === deletedNode) {
                $o = void undefined;
            }
            return !!deletedNode;
        },
        get: function(key) {
            return listGet($o, key);
        },
        has: function(key) {
            return listHas($o, key);
        },
        set: function(key, value) {
            if (!$o) {
                // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
                $o = {
                    next: void undefined
                };
            }
            // eslint-disable-next-line no-extra-parens
            listSet($o, key, value);
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
};
}),
"[project]/node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Object;
}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./abs')} */ module.exports = Math.abs;
}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./floor')} */ module.exports = Math.floor;
}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./max')} */ module.exports = Math.max;
}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./min')} */ module.exports = Math.min;
}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./pow')} */ module.exports = Math.pow;
}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./round')} */ module.exports = Math.round;
}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}),
"[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $isNaN = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js [app-route] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}),
"[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}),
"[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js [app-route] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}),
"[project]/node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}),
"[project]/node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}),
"[project]/node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}),
"[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}),
"[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $Object = __turbopack_context__.r("[project]/node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js [app-route] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}),
"[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var reflectGetProto = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}),
"[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}),
"[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var implementation = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js [app-route] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-route] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js [app-route] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}),
"[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js [app-route] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}),
"[project]/node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBind = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js [app-route] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js [app-route] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}),
"[project]/node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}),
"[project]/node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js [app-route] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js [app-route] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js [app-route] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js [app-route] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js [app-route] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js [app-route] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js [app-route] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js [app-route] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js [app-route] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js [app-route] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js [app-route] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js [app-route] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js [app-route] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js [app-route] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js [app-route] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js [app-route] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js [app-route] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js [app-route] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js [app-route] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}),
"[project]/node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js [app-route] (ecmascript)");
var callBindBasic = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js [app-route] (ecmascript)");
/** @type {(thisArg: string, searchString: string, position?: number) => number} */ var $indexOf = callBindBasic([
    GetIntrinsic('%String.prototype.indexOf%')
]);
/** @type {import('.')} */ module.exports = function callBoundIntrinsic(name, allowMissing) {
    /* eslint no-extra-parens: 0 */ var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
        return callBindBasic([
            intrinsic
        ]);
    }
    return intrinsic;
};
}),
"[project]/node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js [app-route] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js [app-route] (ecmascript)");
var inspect = __turbopack_context__.r("[project]/node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $Map = GetIntrinsic('%Map%', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */ var $mapGet = callBound('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */ var $mapSet = callBound('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */ var $mapHas = callBound('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */ var $mapDelete = callBound('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */ var $mapSize = callBound('Map.prototype.size', true);
/** @type {import('.')} */ module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
    /** @typedef {ReturnType<typeof getSideChannelMap>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {Map<K, V> | undefined} */ var $m;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            if ($m) {
                var result = $mapDelete($m, key);
                if ($mapSize($m) === 0) {
                    $m = void undefined;
                }
                return result;
            }
            return false;
        },
        get: function(key) {
            if ($m) {
                return $mapGet($m, key);
            }
        },
        has: function(key) {
            if ($m) {
                return $mapHas($m, key);
            }
            return false;
        },
        set: function(key, value) {
            if (!$m) {
                // @ts-expect-error TS can't handle narrowing a variable inside a closure
                $m = new $Map();
            }
            $mapSet($m, key, value);
        }
    };
    // @ts-expect-error TODO: figure out why TS is erroring here
    return channel;
};
}),
"[project]/node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js [app-route] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js [app-route] (ecmascript)");
var inspect = __turbopack_context__.r("[project]/node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js [app-route] (ecmascript)");
var getSideChannelMap = __turbopack_context__.r("[project]/node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $WeakMap = GetIntrinsic('%WeakMap%', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */ var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */ var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */ var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */ var $weakMapDelete = callBound('WeakMap.prototype.delete', true);
/** @type {import('.')} */ module.exports = $WeakMap ? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
    /** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */ /** @typedef {Parameters<Channel['get']>[0]} K */ /** @typedef {Parameters<Channel['set']>[1]} V */ /** @type {WeakMap<K & object, V> | undefined} */ var $wm;
    /** @type {Channel | undefined} */ var $m;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if ($wm) {
                    return $weakMapDelete($wm, key);
                }
            } else if (getSideChannelMap) {
                if ($m) {
                    return $m['delete'](key);
                }
            }
            return false;
        },
        get: function(key) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if ($wm) {
                    return $weakMapGet($wm, key);
                }
            }
            return $m && $m.get(key);
        },
        has: function(key) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if ($wm) {
                    return $weakMapHas($wm, key);
                }
            }
            return !!$m && $m.has(key);
        },
        set: function(key, value) {
            if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
                if (!$wm) {
                    $wm = new $WeakMap();
                }
                $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
                if (!$m) {
                    $m = getSideChannelMap();
                }
                // eslint-disable-next-line no-extra-parens
                /** @type {NonNullable<typeof $m>} */ $m.set(key, value);
            }
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
} : getSideChannelMap;
}),
"[project]/node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $TypeError = __turbopack_context__.r("[project]/node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js [app-route] (ecmascript)");
var inspect = __turbopack_context__.r("[project]/node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js [app-route] (ecmascript)");
var getSideChannelList = __turbopack_context__.r("[project]/node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js [app-route] (ecmascript)");
var getSideChannelMap = __turbopack_context__.r("[project]/node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js [app-route] (ecmascript)");
var getSideChannelWeakMap = __turbopack_context__.r("[project]/node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js [app-route] (ecmascript)");
var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
/** @type {import('.')} */ module.exports = function getSideChannel() {
    /** @typedef {ReturnType<typeof getSideChannel>} Channel */ /** @type {Channel | undefined} */ var $channelData;
    /** @type {Channel} */ var channel = {
        assert: function(key) {
            if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
            }
        },
        'delete': function(key) {
            return !!$channelData && $channelData['delete'](key);
        },
        get: function(key) {
            return $channelData && $channelData.get(key);
        },
        has: function(key) {
            return !!$channelData && $channelData.has(key);
        },
        set: function(key, value) {
            if (!$channelData) {
                $channelData = makeChannel();
            }
            $channelData.set(key, value);
        }
    };
    // @ts-expect-error TODO: figure out why this is erroring
    return channel;
};
}),
"[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/formats.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};
module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function(value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function(value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};
}),
"[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var formats = __turbopack_context__.r("[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/formats.js [app-route] (ecmascript)");
var getSideChannel = __turbopack_context__.r("[project]/node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js [app-route] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
// Track objects created from arrayLimit overflow using side-channel
// Stores the current max numeric index for O(1) lookup
var overflowChannel = getSideChannel();
var markOverflow = function markOverflow(obj, maxIndex) {
    overflowChannel.set(obj, maxIndex);
    return obj;
};
var isOverflow = function isOverflow(obj) {
    return overflowChannel.has(obj);
};
var getMaxIndex = function getMaxIndex(obj) {
    return overflowChannel.get(obj);
};
var setMaxIndex = function setMaxIndex(obj, maxIndex) {
    overflowChannel.set(obj, maxIndex);
};
var hexTable = function() {
    var array = [];
    for(var i = 0; i < 256; ++i){
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }
    return array;
}();
var compactQueue = function compactQueue(queue) {
    while(queue.length > 1){
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
            var compacted = [];
            for(var j = 0; j < obj.length; ++j){
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }
            item.obj[item.prop] = compacted;
        }
    }
};
var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? {
        __proto__: null
    } : {};
    for(var i = 0; i < source.length; ++i){
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }
    return obj;
};
var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */ if (!source) {
        return target;
    }
    if (typeof source !== 'object' && typeof source !== 'function') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (isOverflow(target)) {
                // Add at next numeric index for overflow objects
                var newIndex = getMaxIndex(target) + 1;
                target[newIndex] = source;
                setMaxIndex(target, newIndex);
            } else if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [
                target,
                source
            ];
        }
        return target;
    }
    if (!target || typeof target !== 'object') {
        if (isOverflow(source)) {
            // Create new object with target at 0, source values shifted by 1
            var sourceKeys = Object.keys(source);
            var result = options && options.plainObjects ? {
                __proto__: null,
                0: target
            } : {
                0: target
            };
            for(var m = 0; m < sourceKeys.length; m++){
                var oldKey = parseInt(sourceKeys[m], 10);
                result[oldKey + 1] = source[sourceKeys[m]];
            }
            return markOverflow(result, getMaxIndex(source) + 1);
        }
        return [
            target
        ].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};
var decode = function(str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};
var limit = 1024;
/* eslint operator-linebreak: [2, "before"] */ var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }
    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }
    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }
    var out = '';
    for(var j = 0; j < string.length; j += limit){
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for(var i = 0; i < segment.length; ++i){
            var c = segment.charCodeAt(i);
            if (c === 0x2D // -
             || c === 0x2E // .
             || c === 0x5F // _
             || c === 0x7E // ~
             || c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A || format === formats.RFC1738 && (c === 0x28 || c === 0x29) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }
            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }
            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F];
                continue;
            }
            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
                continue;
            }
            i += 1;
            c = 0x10000 + ((c & 0x3FF) << 10 | segment.charCodeAt(i) & 0x3FF);
            arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
        }
        out += arr.join('');
    }
    return out;
};
var compact = function compact(value) {
    var queue = [
        {
            obj: {
                o: value
            },
            prop: 'o'
        }
    ];
    var refs = [];
    for(var i = 0; i < queue.length; ++i){
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for(var j = 0; j < keys.length; ++j){
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({
                    obj: obj,
                    prop: key
                });
                refs.push(val);
            }
        }
    }
    compactQueue(queue);
    return value;
};
var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};
var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine(a, b, arrayLimit, plainObjects) {
    // If 'a' is already an overflow object, add to it
    if (isOverflow(a)) {
        var newIndex = getMaxIndex(a) + 1;
        a[newIndex] = b;
        setMaxIndex(a, newIndex);
        return a;
    }
    var result = [].concat(a, b);
    if (result.length > arrayLimit) {
        return markOverflow(arrayToObject(result, {
            plainObjects: plainObjects
        }), result.length - 1);
    }
    return result;
};
var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for(var i = 0; i < val.length; i += 1){
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};
module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isOverflow: isOverflow,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};
}),
"[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/stringify.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var getSideChannel = __turbopack_context__.r("[project]/node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js [app-route] (ecmascript)");
var utils = __turbopack_context__.r("[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/utils.js [app-route] (ecmascript)");
var formats = __turbopack_context__.r("[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/formats.js [app-route] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};
var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [
        valueOrArray
    ]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    filter: void undefined,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || typeof v === 'symbol' || typeof v === 'bigint';
};
var sentinel = {};
var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag){
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }
    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }
        obj = '';
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [
                formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))
            ];
        }
        return [
            formatter(prefix) + '=' + formatter(String(obj))
        ];
    }
    var values = [];
    if (typeof obj === 'undefined') {
        return values;
    }
    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [
            {
                value: obj.length > 0 ? obj.join(',') || null : void undefined
            }
        ];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;
    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }
    for(var j = 0; j < objKeys.length; ++j){
        var key = objKeys[j];
        var value = typeof key === 'object' && key && typeof key.value !== 'undefined' ? key.value : obj[key];
        if (skipNulls && value === null) {
            continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];
    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }
    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};
module.exports = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== 'object' || obj === null) {
        return '';
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;
    if (!objKeys) {
        objKeys = Object.keys(obj);
    }
    if (options.sort) {
        objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for(var i = 0; i < objKeys.length; ++i){
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
            continue;
        }
        pushToArray(keys, stringify(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';
    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }
    return joined.length > 0 ? prefix + joined : '';
};
}),
"[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/parse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/utils.js [app-route] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
};
var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};
var parseArrayValue = function(val, options, currentArrayLength) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
    }
    return val;
};
// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')
// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')
var parseValues = function parseQueryStringValues(str, options) {
    var obj = {
        __proto__: null
    };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit + 1 : limit);
    if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
    }
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
        for(i = 0; i < parts.length; ++i){
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }
    for(i = 0; i < parts.length; ++i){
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            if (key !== null) {
                val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray(obj[key]) ? obj[key].length : 0), function(encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                });
            }
        }
        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(String(val));
        }
        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [
                val
            ] : val;
        }
        if (key !== null) {
            var existing = has.call(obj, key);
            if (existing && options.duplicates === 'combine') {
                obj[key] = utils.combine(obj[key], val, options.arrayLimit, options.plainObjects);
            } else if (!existing || options.duplicates === 'last') {
                obj[key] = val;
            }
        }
    }
    return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
        var parentKey = chain.slice(0, -1).join('');
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for(var i = chain.length - 1; i >= 0; --i){
        var obj;
        var root = chain[i];
        if (root === '[]' && options.parseArrays) {
            if (utils.isOverflow(leaf)) {
                // leaf is already an overflow object, preserve it
                obj = leaf;
            } else {
                obj = options.allowEmptyArrays && (leaf === '' || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf, options.arrayLimit, options.plainObjects);
            }
        } else {
            obj = options.plainObjects ? {
                __proto__: null
            } : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = {
                    0: leaf
                };
            } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }
        leaf = obj;
    }
    return leaf;
};
var splitKeyIntoSegments = function splitKeyIntoSegments(givenKey, options) {
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
    if (options.depth <= 0) {
        if (!options.plainObjects && has.call(Object.prototype, key)) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        return [
            key
        ];
    }
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(parent);
    }
    var i = 0;
    while((segment = child.exec(key)) !== null && i < options.depth){
        i += 1;
        var segmentContent = segment[1].slice(1, -1);
        if (!options.plainObjects && has.call(Object.prototype, segmentContent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }
    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }
    return keys;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }
    var keys = splitKeyIntoSegments(givenKey, options);
    if (!keys) {
        return;
    }
    return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;
    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
    };
};
module.exports = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? {
            __proto__: null
        } : {};
    }
    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? {
        __proto__: null
    } : {};
    // Iterate over the keys and setup the new object
    var keys = Object.keys(tempObj);
    for(var i = 0; i < keys.length; ++i){
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
        return obj;
    }
    return utils.compact(obj);
};
}),
"[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var stringify = __turbopack_context__.r("[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/stringify.js [app-route] (ecmascript)");
var parse = __turbopack_context__.r("[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/parse.js [app-route] (ecmascript)");
var formats = __turbopack_context__.r("[project]/node_modules/.pnpm/qs@6.14.1/node_modules/qs/lib/formats.js [app-route] (ecmascript)");
module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};
}),
"[project]/node_modules/.pnpm/yesql@7.0.0/node_modules/yesql/yesql.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const matchQuoted = /('[^']*(\\.[^'\\]*)*')/;
const matchDoubleQuoted = /("[^"]*(\\.[^"\\]*)*")/;
const readSqlFiles = (dir, options = {})=>{
    return fs.readdirSync(dir).filter((file)=>{
        return file.endsWith('.sql');
    }).map((file)=>{
        return {
            name: file,
            content: fs.readFileSync(path.resolve(dir, file), 'utf8').replace(/\r\n/g, '\n')
        };
    }).reduce((acc, value)=>{
        acc[value.name] = value.content;
        value.content.split('\n\n').reduce((sqls, lines)=>{
            if (lines.trim().startsWith('--')) {
                sqls.push(lines);
            } else if (sqls.length) {
                sqls[sqls.length - 1] += '\n\n' + lines;
            }
            return sqls;
        }, []).forEach((sql)=>{
            if (sql.trim().startsWith('--')) {
                const sqlName = sql.split('\n')[0].trim().substring(2).trim();
                if (acc[sqlName]) {
                    throw new Error('Duplicate SQL query name "' + sqlName + '" found, please rename other one.');
                }
                acc[sqlName] = options.type ? module.exports[options.type](sql, options) : sql;
            }
        });
        return acc;
    }, {});
};
const pg = (query, options = {})=>{
    return (data = {})=>{
        const values = [];
        const text = query// remove -- comments
        .replace(/--.*$/gm, '')// remove /* */ comments
        .replace(/\/\*(\*(?!\/)|[^*])*\*\//g, '').split(matchQuoted).map((part)=>{
            if (!part || matchQuoted.test(part)) {
                return part;
            } else {
                return part.split(matchDoubleQuoted).map((part)=>{
                    if (!part || matchDoubleQuoted.test(part)) {
                        return part;
                    } else {
                        return part.replace(/(::?)([a-zA-Z0-9_]+)/g, (_, prefix, key)=>{
                            if (prefix !== ':') {
                                return prefix + key;
                            } else if (key in data) {
                                values.push(data[key]);
                                return '$' + values.length;
                            } else if (options.useNullForMissing) {
                                values.push(null);
                                return '$' + values.length;
                            } else {
                                return errorMissingValue(key, query, data);
                            }
                        });
                    }
                }).join('');
            }
        }).join('').trim();
        return {
            text,
            values
        };
    };
};
const mysql = (query, options = {})=>{
    return (data = {})=>{
        const values = [];
        const sql = query.split(matchQuoted).map((part)=>{
            if (!part || matchQuoted.test(part)) {
                return part;
            } else {
                return part.split(matchDoubleQuoted).map((part)=>{
                    if (!part || matchDoubleQuoted.test(part)) {
                        return part;
                    } else {
                        return part.replace(/(::?)([a-zA-Z0-9_]+)/g, (_, prefix, key)=>{
                            if (key in data) {
                                values.push(data[key]);
                                return prefix.replace(/:/g, '?');
                            } else if (options.useNullForMissing) {
                                values.push(null);
                                return prefix.replace(/:/g, '?');
                            } else {
                                return errorMissingValue(key, query, data);
                            }
                        });
                    }
                }).join('');
            }
        }).join('').trim();
        return {
            sql,
            values
        };
    };
};
const errorMissingValue = (key, query, data)=>{
    throw new Error('Missing value for statement.\n' + key + ' not provided for statement:\n' + query + '\nthis was provided:\n' + JSON.stringify(data));
};
module.exports = readSqlFiles;
module.exports.pg = pg;
module.exports.mysql = mysql;
}),
"[project]/node_modules/.pnpm/postgres-array@2.0.0/node_modules/postgres-array/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.parse = function(source, transform) {
    return new ArrayParser(source, transform).parse();
};
class ArrayParser {
    constructor(source, transform){
        this.source = source;
        this.transform = transform || identity;
        this.position = 0;
        this.entries = [];
        this.recorded = [];
        this.dimension = 0;
    }
    isEof() {
        return this.position >= this.source.length;
    }
    nextCharacter() {
        var character = this.source[this.position++];
        if (character === '\\') {
            return {
                value: this.source[this.position++],
                escaped: true
            };
        }
        return {
            value: character,
            escaped: false
        };
    }
    record(character) {
        this.recorded.push(character);
    }
    newEntry(includeEmpty) {
        var entry;
        if (this.recorded.length > 0 || includeEmpty) {
            entry = this.recorded.join('');
            if (entry === 'NULL' && !includeEmpty) {
                entry = null;
            }
            if (entry !== null) entry = this.transform(entry);
            this.entries.push(entry);
            this.recorded = [];
        }
    }
    consumeDimensions() {
        if (this.source[0] === '[') {
            while(!this.isEof()){
                var char = this.nextCharacter();
                if (char.value === '=') break;
            }
        }
    }
    parse(nested) {
        var character, parser, quote;
        this.consumeDimensions();
        while(!this.isEof()){
            character = this.nextCharacter();
            if (character.value === '{' && !quote) {
                this.dimension++;
                if (this.dimension > 1) {
                    parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
                    this.entries.push(parser.parse(true));
                    this.position += parser.position - 2;
                }
            } else if (character.value === '}' && !quote) {
                this.dimension--;
                if (!this.dimension) {
                    this.newEntry();
                    if (nested) return this.entries;
                }
            } else if (character.value === '"' && !character.escaped) {
                if (quote) this.newEntry(true);
                quote = !quote;
            } else if (character.value === ',' && !quote) {
                this.newEntry();
            } else {
                this.record(character.value);
            }
        }
        if (this.dimension !== 0) {
            throw new Error('array dimension not balanced');
        }
        return this.entries;
    }
}
function identity(value) {
    return value;
}
}),
"[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/arrayParser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var array = __turbopack_context__.r("[project]/node_modules/.pnpm/postgres-array@2.0.0/node_modules/postgres-array/index.js [app-route] (ecmascript)");
module.exports = {
    create: function(source, transform) {
        return {
            parse: function() {
                return array.parse(source, transform);
            }
        };
    }
};
}),
"[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/textParsers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var array = __turbopack_context__.r("[project]/node_modules/.pnpm/postgres-array@2.0.0/node_modules/postgres-array/index.js [app-route] (ecmascript)");
var arrayParser = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/arrayParser.js [app-route] (ecmascript)");
var parseDate = __turbopack_context__.r("[project]/node_modules/.pnpm/postgres-date@1.0.7/node_modules/postgres-date/index.js [app-route] (ecmascript)");
var parseInterval = __turbopack_context__.r("[project]/node_modules/.pnpm/postgres-interval@1.2.0/node_modules/postgres-interval/index.js [app-route] (ecmascript)");
var parseByteA = __turbopack_context__.r("[project]/node_modules/.pnpm/postgres-bytea@1.0.1/node_modules/postgres-bytea/index.js [app-route] (ecmascript)");
function allowNull(fn) {
    return function nullAllowed(value) {
        if (value === null) return value;
        return fn(value);
    };
}
function parseBool(value) {
    if (value === null) return value;
    return value === 'TRUE' || value === 't' || value === 'true' || value === 'y' || value === 'yes' || value === 'on' || value === '1';
}
function parseBoolArray(value) {
    if (!value) return null;
    return array.parse(value, parseBool);
}
function parseBaseTenInt(string) {
    return parseInt(string, 10);
}
function parseIntegerArray(value) {
    if (!value) return null;
    return array.parse(value, allowNull(parseBaseTenInt));
}
function parseBigIntegerArray(value) {
    if (!value) return null;
    return array.parse(value, allowNull(function(entry) {
        return parseBigInteger(entry).trim();
    }));
}
var parsePointArray = function(value) {
    if (!value) {
        return null;
    }
    var p = arrayParser.create(value, function(entry) {
        if (entry !== null) {
            entry = parsePoint(entry);
        }
        return entry;
    });
    return p.parse();
};
var parseFloatArray = function(value) {
    if (!value) {
        return null;
    }
    var p = arrayParser.create(value, function(entry) {
        if (entry !== null) {
            entry = parseFloat(entry);
        }
        return entry;
    });
    return p.parse();
};
var parseStringArray = function(value) {
    if (!value) {
        return null;
    }
    var p = arrayParser.create(value);
    return p.parse();
};
var parseDateArray = function(value) {
    if (!value) {
        return null;
    }
    var p = arrayParser.create(value, function(entry) {
        if (entry !== null) {
            entry = parseDate(entry);
        }
        return entry;
    });
    return p.parse();
};
var parseIntervalArray = function(value) {
    if (!value) {
        return null;
    }
    var p = arrayParser.create(value, function(entry) {
        if (entry !== null) {
            entry = parseInterval(entry);
        }
        return entry;
    });
    return p.parse();
};
var parseByteAArray = function(value) {
    if (!value) {
        return null;
    }
    return array.parse(value, allowNull(parseByteA));
};
var parseInteger = function(value) {
    return parseInt(value, 10);
};
var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
        return valStr;
    }
    return value;
};
var parseJsonArray = function(value) {
    if (!value) {
        return null;
    }
    return array.parse(value, allowNull(JSON.parse));
};
var parsePoint = function(value) {
    if (value[0] !== '(') {
        return null;
    }
    value = value.substring(1, value.length - 1).split(',');
    return {
        x: parseFloat(value[0]),
        y: parseFloat(value[1])
    };
};
var parseCircle = function(value) {
    if (value[0] !== '<' && value[1] !== '(') {
        return null;
    }
    var point = '(';
    var radius = '';
    var pointParsed = false;
    for(var i = 2; i < value.length - 1; i++){
        if (!pointParsed) {
            point += value[i];
        }
        if (value[i] === ')') {
            pointParsed = true;
            continue;
        } else if (!pointParsed) {
            continue;
        }
        if (value[i] === ',') {
            continue;
        }
        radius += value[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
};
var init = function(register) {
    register(20, parseBigInteger); // int8
    register(21, parseInteger); // int2
    register(23, parseInteger); // int4
    register(26, parseInteger); // oid
    register(700, parseFloat); // float4/real
    register(701, parseFloat); // float8/double
    register(16, parseBool);
    register(1082, parseDate); // date
    register(1114, parseDate); // timestamp without timezone
    register(1184, parseDate); // timestamp
    register(600, parsePoint); // point
    register(651, parseStringArray); // cidr[]
    register(718, parseCircle); // circle
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray); // _int2
    register(1007, parseIntegerArray); // _int4
    register(1028, parseIntegerArray); // oid[]
    register(1016, parseBigIntegerArray); // _int8
    register(1017, parsePointArray); // point[]
    register(1021, parseFloatArray); // _float4
    register(1022, parseFloatArray); // _float8
    register(1231, parseFloatArray); // _numeric
    register(1014, parseStringArray); //char
    register(1015, parseStringArray); //varchar
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray); // macaddr[]
    register(1041, parseStringArray); // inet[]
    register(1115, parseDateArray); // timestamp without time zone[]
    register(1182, parseDateArray); // _date
    register(1185, parseDateArray); // timestamp with time zone[]
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON)); // json
    register(3802, JSON.parse.bind(JSON)); // jsonb
    register(199, parseJsonArray); // json[]
    register(3807, parseJsonArray); // jsonb[]
    register(3907, parseStringArray); // numrange[]
    register(2951, parseStringArray); // uuid[]
    register(791, parseStringArray); // money[]
    register(1183, parseStringArray); // time[]
    register(1270, parseStringArray); // timetz[]
};
module.exports = {
    init: init
};
}),
"[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/binaryParsers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var parseInt64 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-int8@1.0.1/node_modules/pg-int8/index.js [app-route] (ecmascript)");
var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits) {
        return lastValue * Math.pow(2, bits) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
        if (invert) {
            return ~value & 0xff;
        }
        return value;
    };
    // read first (maybe partial) byte
    var mask = 0xff;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
        mask = 0xff << 8 - bits & 0xff;
        firstBits = bits;
    }
    if (offset) {
        mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
        result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    // read bytes
    var bytes = bits + offset >> 3;
    for(var i = offsetBytes + 1; i < bytes; i++){
        result = callback(result, inv(data[i]), 8);
    }
    // bits to read, that are not a complete byte
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
        result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
};
var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
        return 0;
    }
    // parse mantissa
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
        if (lastValue === 0) {
            lastValue = 1;
        }
        for(var i = 1; i <= bits; i++){
            precisionBitsCounter /= 2;
            if ((newValue & 0x1 << bits - i) > 0) {
                lastValue += precisionBitsCounter;
            }
        }
        return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    // special cases
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
        if (mantissa === 0) {
            return sign === 0 ? Infinity : -Infinity;
        }
        return NaN;
    }
    // normale number
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
};
var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
        return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
};
var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
        return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
};
var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
};
var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
};
var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 0xc000) {
        return NaN;
    }
    var weight = Math.pow(10000, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for(var i = 0; i < ndigits; i++){
        result += parseBits(value, 16, 64 + 16 * i) * weight;
        weight /= 10000;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
};
var parseDate = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    // discard usecs and shift from 2000 to 1970
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
        result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    // add microseconds to the date
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
        return this.usec;
    };
    result.setMicroSeconds = function(value) {
        this.usec = value;
    };
    result.getUTCMicroSeconds = function() {
        return this.usec;
    };
    return result;
};
var parseArray = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for(var i = 0; i < dim; i++){
        // parse dimension
        dims[i] = parseBits(value, 32, offset);
        offset += 32;
        // ignore lower bounds
        offset += 32;
    }
    var parseElement = function(elementType) {
        // parse content length
        var length = parseBits(value, 32, offset);
        offset += 32;
        // parse null values
        if (length == 0xffffffff) {
            return null;
        }
        var result;
        if (elementType == 0x17 || elementType == 0x14) {
            // int/bigint
            result = parseBits(value, length * 8, offset);
            offset += length * 8;
            return result;
        } else if (elementType == 0x19) {
            // string
            result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
            return result;
        } else {
            console.log("ERROR: ElementType not implemented: " + elementType);
        }
    };
    var parse = function(dimension, elementType) {
        var array = [];
        var i;
        if (dimension.length > 1) {
            var count = dimension.shift();
            for(i = 0; i < count; i++){
                array[i] = parse(dimension, elementType);
            }
            dimension.unshift(count);
        } else {
            for(i = 0; i < dimension[0]; i++){
                array[i] = parseElement(elementType);
            }
        }
        return array;
    };
    return parse(dims, elementType);
};
var parseText = function(value) {
    return value.toString('utf8');
};
var parseBool = function(value) {
    if (value === null) return null;
    return parseBits(value, 8) > 0;
};
var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
};
module.exports = {
    init: init
};
}),
"[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/builtins.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Following query was used to generate this file:

 SELECT json_object_agg(UPPER(PT.typname), PT.oid::int4 ORDER BY pt.oid)
 FROM pg_type PT
 WHERE typnamespace = (SELECT pgn.oid FROM pg_namespace pgn WHERE nspname = 'pg_catalog') -- Take only builting Postgres types with stable OID (extension types are not guaranted to be stable)
 AND typtype = 'b' -- Only basic types
 AND typelem = 0 -- Ignore aliases
 AND typisdefined -- Ignore undefined types
 */ module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
};
}),
"[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var textParsers = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/textParsers.js [app-route] (ecmascript)");
var binaryParsers = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/binaryParsers.js [app-route] (ecmascript)");
var arrayParser = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/arrayParser.js [app-route] (ecmascript)");
var builtinTypes = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/builtins.js [app-route] (ecmascript)");
exports.getTypeParser = getTypeParser;
exports.setTypeParser = setTypeParser;
exports.arrayParser = arrayParser;
exports.builtins = builtinTypes;
var typeParsers = {
    text: {},
    binary: {}
};
//the empty parse function
function noParse(val) {
    return String(val);
}
;
//returns a function used to convert a specific type (specified by
//oid) into a result javascript type
//note: the oid can be obtained via the following sql query:
//SELECT oid FROM pg_type WHERE typname = 'TYPE_NAME_HERE';
function getTypeParser(oid, format) {
    format = format || 'text';
    if (!typeParsers[format]) {
        return noParse;
    }
    return typeParsers[format][oid] || noParse;
}
;
function setTypeParser(oid, format, parseFn) {
    if (typeof format == 'function') {
        parseFn = format;
        format = 'text';
    }
    typeParsers[format][oid] = parseFn;
}
;
textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
});
binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
});
}),
"[project]/node_modules/.pnpm/postgres-date@1.0.7/node_modules/postgres-date/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
var INFINITY = /^-?infinity$/;
module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
        // Capitalize to Infinity before passing to Number
        return Number(isoDate.replace('i', 'I'));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
        // Force YYYY-MM-DD dates to be parsed as local time
        return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
        year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
        date = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
        // Account for years from 0 to 99 being interpreted as 1900-1999
        // by Date.UTC / the multi-argument form of the Date constructor
        if (is0To99(year)) {
            date.setUTCFullYear(year);
        }
        if (offset !== 0) {
            date.setTime(date.getTime() - offset);
        }
    } else {
        date = new Date(year, month, day, hour, minute, second, ms);
        if (is0To99(year)) {
            date.setFullYear(year);
        }
    }
    return date;
};
function getDate(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
        return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
        year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    // YYYY-MM-DD will be parsed as local time
    var date = new Date(year, month, day);
    if (is0To99(year)) {
        date.setFullYear(year);
    }
    return date;
}
// match timezones:
// Z (UTC)
// -05
// +06:30
function timeZoneOffset(isoDate) {
    if (isoDate.endsWith('+00')) {
        return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(' ')[1]);
    if (!zone) return;
    var type = zone[1];
    if (type === 'Z') {
        return 0;
    }
    var sign = type === '-' ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
}
function bcYearToNegativeYear(year) {
    // Account for numerical difference between representations of BC years
    // See: https://github.com/bendrucker/postgres-date/issues/5
    return -(year - 1);
}
function is0To99(num) {
    return num >= 0 && num < 100;
}
}),
"[project]/node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/mutable.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source){
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
}
}),
"[project]/node_modules/.pnpm/postgres-interval@1.2.0/node_modules/postgres-interval/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var extend = __turbopack_context__.r("[project]/node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/mutable.js [app-route] (ecmascript)");
module.exports = PostgresInterval;
function PostgresInterval(raw) {
    if (!(this instanceof PostgresInterval)) {
        return new PostgresInterval(raw);
    }
    extend(this, parse(raw));
}
var properties = [
    'seconds',
    'minutes',
    'hours',
    'days',
    'months',
    'years'
];
PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    // In addition to `properties`, we need to account for fractions of seconds.
    if (this.milliseconds && filtered.indexOf('seconds') < 0) {
        filtered.push('seconds');
    }
    if (filtered.length === 0) return '0';
    return filtered.map(function(property) {
        var value = this[property] || 0;
        // Account for fractional part of seconds,
        // remove trailing zeroes.
        if (property === 'seconds' && this.milliseconds) {
            value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, '');
        }
        return value + ' ' + property;
    }, this).join(' ');
};
var propertiesISOEquivalent = {
    years: 'Y',
    months: 'M',
    days: 'D',
    hours: 'H',
    minutes: 'M',
    seconds: 'S'
};
var dateProperties = [
    'years',
    'months',
    'days'
];
var timeProperties = [
    'hours',
    'minutes',
    'seconds'
];
// according to ISO 8601
PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join('');
    var timePart = timeProperties.map(buildProperty, this).join('');
    return 'P' + datePart + 'T' + timePart;
    //TURBOPACK unreachable
    ;
    function buildProperty(property) {
        var value = this[property] || 0;
        // Account for fractional part of seconds,
        // remove trailing zeroes.
        if (property === 'seconds' && this.milliseconds) {
            value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, '');
        }
        return value + propertiesISOEquivalent[property];
    }
};
var NUMBER = '([+-]?\\d+)';
var YEAR = NUMBER + '\\s+years?';
var MONTH = NUMBER + '\\s+mons?';
var DAY = NUMBER + '\\s+days?';
var TIME = '([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?';
var INTERVAL = new RegExp([
    YEAR,
    MONTH,
    DAY,
    TIME
].map(function(regexString) {
    return '(' + regexString + ')?';
}).join('\\s*'));
// Positions of values in regex match
var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
};
// We can use negative time
var negatives = [
    'hours',
    'minutes',
    'seconds',
    'milliseconds'
];
function parseMilliseconds(fraction) {
    // add omitted zeroes
    var microseconds = fraction + '000000'.slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
}
function parse(interval) {
    if (!interval) return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === '-';
    return Object.keys(positions).reduce(function(parsed, property) {
        var position = positions[property];
        var value = matches[position];
        // no empty string
        if (!value) return parsed;
        // milliseconds are actually microseconds (up to 6 digits)
        // with omitted trailing zeroes.
        value = property === 'milliseconds' ? parseMilliseconds(value) : parseInt(value, 10);
        // no zeros
        if (!value) return parsed;
        if (isNegative && ~negatives.indexOf(property)) {
            value *= -1;
        }
        parsed[property] = value;
        return parsed;
    }, {});
}
}),
"[project]/node_modules/.pnpm/postgres-bytea@1.0.1/node_modules/postgres-bytea/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bufferFrom = Buffer.from || Buffer;
module.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
        // new 'hex' style response (pg >9.0)
        return bufferFrom(input.substr(2), 'hex');
    }
    var output = '';
    var i = 0;
    while(i < input.length){
        if (input[i] !== '\\') {
            output += input[i];
            ++i;
        } else {
            if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
                output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
                i += 4;
            } else {
                var backslashes = 1;
                while(i + backslashes < input.length && input[i + backslashes] === '\\'){
                    backslashes++;
                }
                for(var k = 0; k < Math.floor(backslashes / 2); ++k){
                    output += '\\';
                }
                i += Math.floor(backslashes / 2) * 2;
            }
        }
    }
    return bufferFrom(output, 'binary');
};
}),
"[project]/node_modules/.pnpm/pg-int8@1.0.1/node_modules/pg-int8/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// selected so (BASE - 1) * 0x100000000 + 0xffffffff is a safe integer
var BASE = 1000000;
function readInt8(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = '';
    if (high < 0) {
        high = ~high + (low === 0);
        low = ~low + 1 >>> 0;
        sign = '-';
    }
    var result = '';
    var carry;
    var t;
    var digits;
    var pad;
    var l;
    var i;
    {
        carry = high % BASE;
        high = high / BASE >>> 0;
        t = 0x100000000 * carry + low;
        low = t / BASE >>> 0;
        digits = '' + (t - BASE * low);
        if (low === 0 && high === 0) {
            return sign + digits + result;
        }
        pad = '';
        l = 6 - digits.length;
        for(i = 0; i < l; i++){
            pad += '0';
        }
        result = pad + digits + result;
    }
    {
        carry = high % BASE;
        high = high / BASE >>> 0;
        t = 0x100000000 * carry + low;
        low = t / BASE >>> 0;
        digits = '' + (t - BASE * low);
        if (low === 0 && high === 0) {
            return sign + digits + result;
        }
        pad = '';
        l = 6 - digits.length;
        for(i = 0; i < l; i++){
            pad += '0';
        }
        result = pad + digits + result;
    }
    {
        carry = high % BASE;
        high = high / BASE >>> 0;
        t = 0x100000000 * carry + low;
        low = t / BASE >>> 0;
        digits = '' + (t - BASE * low);
        if (low === 0 && high === 0) {
            return sign + digits + result;
        }
        pad = '';
        l = 6 - digits.length;
        for(i = 0; i < l; i++){
            pad += '0';
        }
        result = pad + digits + result;
    }
    {
        carry = high % BASE;
        t = 0x100000000 * carry + low;
        digits = '' + t % BASE;
        return sign + digits + result;
    }
}
module.exports = readInt8;
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/defaults.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

let user;
try {
    user = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : process.env.USER;
} catch  {
// ignore, e.g., Deno without --allow-env
}
module.exports = {
    // database host. defaults to localhost
    host: 'localhost',
    // database user's name
    user,
    // name of database to connect
    database: undefined,
    // database user's password
    password: null,
    // a Postgres connection string to be used instead of setting individual connection items
    // NOTE:  Setting this value will cause it to override any other value (such as database or user) defined
    // in the defaults object.
    connectionString: undefined,
    // database port
    port: 5432,
    // number of rows to return at a time from a prepared statement's
    // portal. 0 will return all rows at once
    rows: 0,
    // binary result mode
    binary: false,
    // Connection pool options - see https://github.com/brianc/node-pg-pool
    // number of connections to use in connection pool
    // 0 will disable connection pooling
    max: 10,
    // max milliseconds a client can go unused before it is removed
    // from the pool and destroyed
    idleTimeoutMillis: 30000,
    client_encoding: '',
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    // max milliseconds any query using this connection will execute for before timing out in error.
    // false=unlimited
    statement_timeout: false,
    // Abort any statement that waits longer than the specified duration in milliseconds while attempting to acquire a lock.
    // false=unlimited
    lock_timeout: false,
    // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds
    // false=unlimited
    idle_in_transaction_session_timeout: false,
    // max milliseconds to wait for query to complete (client side)
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
};
const pgTypes = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js [app-route] (ecmascript)");
// save default parsers
const parseBigInteger = pgTypes.getTypeParser(20, 'text');
const parseBigIntegerArray = pgTypes.getTypeParser(1016, 'text');
// parse int8 so you can get your count values as actual numbers
module.exports.__defineSetter__('parseInt8', function(val) {
    pgTypes.setTypeParser(20, 'text', val ? pgTypes.getTypeParser(23, 'text') : parseBigInteger);
    pgTypes.setTypeParser(1016, 'text', val ? pgTypes.getTypeParser(1007, 'text') : parseBigIntegerArray);
});
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const defaults = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/defaults.js [app-route] (ecmascript)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const { isDate } = util.types || util // Node 8 doesn't have `util.types`
;
function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    return '"' + escaped + '"';
}
// convert a JS array to a postgres array literal
// uses comma separator so won't work for types like box that use
// a different array separator.
function arrayString(val) {
    let result = '{';
    for(let i = 0; i < val.length; i++){
        if (i > 0) {
            result = result + ',';
        }
        if (val[i] === null || typeof val[i] === 'undefined') {
            result = result + 'NULL';
        } else if (Array.isArray(val[i])) {
            result = result + arrayString(val[i]);
        } else if (ArrayBuffer.isView(val[i])) {
            let item = val[i];
            if (!(item instanceof Buffer)) {
                const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
                if (buf.length === item.byteLength) {
                    item = buf;
                } else {
                    item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
                }
            }
            result += '\\\\x' + item.toString('hex');
        } else {
            result += escapeElement(prepareValue(val[i]));
        }
    }
    result = result + '}';
    return result;
}
// converts values from javascript types
// to their 'raw' counterparts for use as a postgres parameter
// note: you can override this function to provide your own conversion mechanism
// for complex types, etc...
const prepareValue = function(val, seen) {
    // null and undefined are both null for postgres
    if (val == null) {
        return null;
    }
    if (typeof val === 'object') {
        if (val instanceof Buffer) {
            return val;
        }
        if (ArrayBuffer.isView(val)) {
            const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
            if (buf.length === val.byteLength) {
                return buf;
            }
            return buf.slice(val.byteOffset, val.byteOffset + val.byteLength) // Node.js v4 does not support those Buffer.from params
            ;
        }
        if (isDate(val)) {
            if (defaults.parseInputDatesAsUTC) {
                return dateToStringUTC(val);
            } else {
                return dateToString(val);
            }
        }
        if (Array.isArray(val)) {
            return arrayString(val);
        }
        return prepareObject(val, seen);
    }
    return val.toString();
};
function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === 'function') {
        seen = seen || [];
        if (seen.indexOf(val) !== -1) {
            throw new Error('circular reference detected while preparing "' + val + '" for query');
        }
        seen.push(val);
        return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
}
function dateToString(date) {
    let offset = -date.getTimezoneOffset();
    let year = date.getFullYear();
    const isBCYear = year < 1;
    if (isBCYear) year = Math.abs(year) + 1; // negative years are 1 off their BC representation
    let ret = String(year).padStart(4, '0') + '-' + String(date.getMonth() + 1).padStart(2, '0') + '-' + String(date.getDate()).padStart(2, '0') + 'T' + String(date.getHours()).padStart(2, '0') + ':' + String(date.getMinutes()).padStart(2, '0') + ':' + String(date.getSeconds()).padStart(2, '0') + '.' + String(date.getMilliseconds()).padStart(3, '0');
    if (offset < 0) {
        ret += '-';
        offset *= -1;
    } else {
        ret += '+';
    }
    ret += String(Math.floor(offset / 60)).padStart(2, '0') + ':' + String(offset % 60).padStart(2, '0');
    if (isBCYear) ret += ' BC';
    return ret;
}
function dateToStringUTC(date) {
    let year = date.getUTCFullYear();
    const isBCYear = year < 1;
    if (isBCYear) year = Math.abs(year) + 1; // negative years are 1 off their BC representation
    let ret = String(year).padStart(4, '0') + '-' + String(date.getUTCMonth() + 1).padStart(2, '0') + '-' + String(date.getUTCDate()).padStart(2, '0') + 'T' + String(date.getUTCHours()).padStart(2, '0') + ':' + String(date.getUTCMinutes()).padStart(2, '0') + ':' + String(date.getUTCSeconds()).padStart(2, '0') + '.' + String(date.getUTCMilliseconds()).padStart(3, '0');
    ret += '+00:00';
    if (isBCYear) ret += ' BC';
    return ret;
}
function normalizeQueryConfig(config, values, callback) {
    // can take in strings or config objects
    config = typeof config === 'string' ? {
        text: config
    } : config;
    if (values) {
        if (typeof values === 'function') {
            config.callback = values;
        } else {
            config.values = values;
        }
    }
    if (callback) {
        config.callback = callback;
    }
    return config;
}
// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
const escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
};
const escapeLiteral = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    if (str == null) {
        return "''";
    }
    if (typeof str !== 'string') {
        return "''";
    }
    for(let i = 0; i < str.length; i++){
        const c = str[i];
        if (c === "'") {
            escaped += c + c;
        } else if (c === '\\') {
            escaped += c + c;
            hasBackslash = true;
        } else {
            escaped += c;
        }
    }
    escaped += "'";
    if (hasBackslash === true) {
        escaped = ' E' + escaped;
    }
    return escaped;
};
module.exports = {
    prepareValue: function prepareValueWrapper(value) {
        // this ensures that extra arguments do not get passed into prepareValue
        // by accident, eg: from calling values.map(utils.prepareValue)
        return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
};
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/utils-webcrypto.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const nodeCrypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
};
/**
 * The Web Crypto API - grabbed from the Node.js library or the global
 * @type Crypto
 */ // eslint-disable-next-line no-undef
const webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
/**
 * The SubtleCrypto API for low level crypto operations.
 * @type SubtleCrypto
 */ const subtleCrypto = webCrypto.subtle;
const textEncoder = new TextEncoder();
/**
 *
 * @param {*} length
 * @returns
 */ function randomBytes(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
}
async function md5(string) {
    try {
        return nodeCrypto.createHash('md5').update(string, 'utf-8').digest('hex');
    } catch (e) {
        // `createHash()` failed so we are probably not in Node.js, use the WebCrypto API instead.
        // Note that the MD5 algorithm on WebCrypto is not available in Node.js.
        // This is why we cannot just use WebCrypto in all environments.
        const data = typeof string === 'string' ? textEncoder.encode(string) : string;
        const hash = await subtleCrypto.digest('MD5', data);
        return Array.from(new Uint8Array(hash)).map((b)=>b.toString(16).padStart(2, '0')).join('');
    }
}
// See AuthenticationMD5Password at https://www.postgresql.org/docs/current/static/protocol-flow.html
async function postgresMd5PasswordHash(user, password, salt) {
    const inner = await md5(password + user);
    const outer = await md5(Buffer.concat([
        Buffer.from(inner),
        salt
    ]));
    return 'md5' + outer;
}
/**
 * Create a SHA-256 digest of the given data
 * @param {Buffer} data
 */ async function sha256(text) {
    return await subtleCrypto.digest('SHA-256', text);
}
async function hashByName(hashName, text) {
    return await subtleCrypto.digest(hashName, text);
}
/**
 * Sign the message with the given key
 * @param {ArrayBuffer} keyBuffer
 * @param {string} msg
 */ async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey('raw', keyBuffer, {
        name: 'HMAC',
        hash: 'SHA-256'
    }, false, [
        'sign'
    ]);
    return await subtleCrypto.sign('HMAC', key, textEncoder.encode(msg));
}
/**
 * Derive a key from the password and salt
 * @param {string} password
 * @param {Uint8Array} salt
 * @param {number} iterations
 */ async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey('raw', textEncoder.encode(password), 'PBKDF2', false, [
        'deriveBits'
    ]);
    const params = {
        name: 'PBKDF2',
        hash: 'SHA-256',
        salt: salt,
        iterations: iterations
    };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, [
        'deriveBits'
    ]);
}
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/utils-legacy.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This file contains crypto utility functions for versions of Node.js < 15.0.0,
// which does not support the WebCrypto.subtle API.
const nodeCrypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
function md5(string) {
    return nodeCrypto.createHash('md5').update(string, 'utf-8').digest('hex');
}
// See AuthenticationMD5Password at https://www.postgresql.org/docs/current/static/protocol-flow.html
function postgresMd5PasswordHash(user, password, salt) {
    const inner = md5(password + user);
    const outer = md5(Buffer.concat([
        Buffer.from(inner),
        salt
    ]));
    return 'md5' + outer;
}
function sha256(text) {
    return nodeCrypto.createHash('sha256').update(text).digest();
}
function hashByName(hashName, text) {
    hashName = hashName.replace(/(\D)-/, '$1'); // e.g. SHA-256 -> SHA256
    return nodeCrypto.createHash(hashName).update(text).digest();
}
function hmacSha256(key, msg) {
    return nodeCrypto.createHmac('sha256', key).update(msg).digest();
}
async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, 'sha256');
}
module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
};
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split('.')[0]) < 15;
if (useLegacyCrypto) {
    // We are on an old version of Node.js that requires legacy crypto utilities.
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/utils-legacy.js [app-route] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/utils-webcrypto.js [app-route] (ecmascript)");
}
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/cert-signatures.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

function x509Error(msg, cert) {
    return new Error('SASL channel binding: ' + msg + ' when parsing public certificate ' + cert.toString('base64'));
}
function readASN1Length(data, index) {
    let length = data[index++];
    if (length < 0x80) return {
        length,
        index
    };
    const lengthBytes = length & 0x7f;
    if (lengthBytes > 4) throw x509Error('bad length', data);
    length = 0;
    for(let i = 0; i < lengthBytes; i++){
        length = length << 8 | data[index++];
    }
    return {
        length,
        index
    };
}
function readASN1OID(data, index) {
    if (data[index++] !== 0x6) throw x509Error('non-OID data', data) // 6 = OID
    ;
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
    index = indexAfterOIDLength;
    const lastIndex = index + OIDLength;
    const byte1 = data[index++];
    let oid = (byte1 / 40 >> 0) + '.' + byte1 % 40;
    while(index < lastIndex){
        // loop over numbers in OID
        let value = 0;
        while(index < lastIndex){
            // loop over bytes in number
            const nextByte = data[index++];
            value = value << 7 | nextByte & 0x7f;
            if (nextByte < 0x80) break;
        }
        oid += '.' + value;
    }
    return {
        oid,
        index
    };
}
function expectASN1Seq(data, index) {
    if (data[index++] !== 0x30) throw x509Error('non-sequence data', data) // 30 = Sequence
    ;
    return readASN1Length(data, index);
}
function signatureAlgorithmHashFromCertificate(data, index) {
    // read this thread: https://www.postgresql.org/message-id/17760-b6c61e752ec07060%40postgresql.org
    if (index === undefined) index = 0;
    index = expectASN1Seq(data, index).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
    index = indexAfterCertInfoLength + certInfoLength; // skip over certificate info
    index = expectASN1Seq(data, index).index; // skip over signature length field
    const { oid, index: indexAfterOID } = readASN1OID(data, index);
    switch(oid){
        // RSA
        case '1.2.840.113549.1.1.4':
            return 'MD5';
        case '1.2.840.113549.1.1.5':
            return 'SHA-1';
        case '1.2.840.113549.1.1.11':
            return 'SHA-256';
        case '1.2.840.113549.1.1.12':
            return 'SHA-384';
        case '1.2.840.113549.1.1.13':
            return 'SHA-512';
        case '1.2.840.113549.1.1.14':
            return 'SHA-224';
        case '1.2.840.113549.1.1.15':
            return 'SHA512-224';
        case '1.2.840.113549.1.1.16':
            return 'SHA512-256';
        // ECDSA
        case '1.2.840.10045.4.1':
            return 'SHA-1';
        case '1.2.840.10045.4.3.1':
            return 'SHA-224';
        case '1.2.840.10045.4.3.2':
            return 'SHA-256';
        case '1.2.840.10045.4.3.3':
            return 'SHA-384';
        case '1.2.840.10045.4.3.4':
            return 'SHA-512';
        // RSASSA-PSS: hash is indicated separately
        case '1.2.840.113549.1.1.10':
            {
                index = indexAfterOID;
                index = expectASN1Seq(data, index).index;
                if (data[index++] !== 0xa0) throw x509Error('non-tag data', data) // a0 = constructed tag 0
                ;
                index = readASN1Length(data, index).index; // skip over tag length field
                index = expectASN1Seq(data, index).index; // skip over sequence length field
                const { oid: hashOID } = readASN1OID(data, index);
                switch(hashOID){
                    // standalone hash OIDs
                    case '1.2.840.113549.2.5':
                        return 'MD5';
                    case '1.3.14.3.2.26':
                        return 'SHA-1';
                    case '2.16.840.1.101.3.4.2.1':
                        return 'SHA-256';
                    case '2.16.840.1.101.3.4.2.2':
                        return 'SHA-384';
                    case '2.16.840.1.101.3.4.2.3':
                        return 'SHA-512';
                }
                throw x509Error('unknown hash OID ' + hashOID, data);
            }
        // Ed25519 -- see https: return//github.com/openssl/openssl/issues/15477
        case '1.3.101.110':
        case '1.3.101.112':
            return 'SHA-512';
        // Ed448 -- still not in pg 17.2 (if supported, digest would be SHAKE256 x 64 bytes)
        case '1.3.101.111':
        case '1.3.101.113':
            throw x509Error('Ed448 certificate channel binding is not currently supported by Postgres');
    }
    throw x509Error('unknown OID ' + oid, data);
}
module.exports = {
    signatureAlgorithmHashFromCertificate
};
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/sasl.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const crypto = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/utils.js [app-route] (ecmascript)");
const { signatureAlgorithmHashFromCertificate } = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/cert-signatures.js [app-route] (ecmascript)");
function startSession(mechanisms, stream) {
    const candidates = [
        'SCRAM-SHA-256'
    ];
    if (stream) candidates.unshift('SCRAM-SHA-256-PLUS'); // higher-priority, so placed first
    const mechanism = candidates.find((candidate)=>mechanisms.includes(candidate));
    if (!mechanism) {
        throw new Error('SASL: Only mechanism(s) ' + candidates.join(' and ') + ' are supported');
    }
    if (mechanism === 'SCRAM-SHA-256-PLUS' && typeof stream.getPeerCertificate !== 'function') {
        // this should never happen if we are really talking to a Postgres server
        throw new Error('SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate');
    }
    const clientNonce = crypto.randomBytes(18).toString('base64');
    const gs2Header = mechanism === 'SCRAM-SHA-256-PLUS' ? 'p=tls-server-end-point' : stream ? 'y' : 'n';
    return {
        mechanism,
        clientNonce,
        response: gs2Header + ',,n=*,r=' + clientNonce,
        message: 'SASLInitialResponse'
    };
}
async function continueSession(session, password, serverData, stream) {
    if (session.message !== 'SASLInitialResponse') {
        throw new Error('SASL: Last message was not SASLInitialResponse');
    }
    if (typeof password !== 'string') {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string');
    }
    if (password === '') {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string');
    }
    if (typeof serverData !== 'string') {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string');
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce');
    } else if (sv.nonce.length === session.clientNonce.length) {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short');
    }
    const clientFirstMessageBare = 'n=*,r=' + session.clientNonce;
    const serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration;
    // without channel binding:
    let channelBinding = stream ? 'eSws' : 'biws' // 'y,,' or 'n,,', base64-encoded
    ;
    // override if channel binding is in use:
    if (session.mechanism === 'SCRAM-SHA-256-PLUS') {
        const peerCert = stream.getPeerCertificate().raw;
        let hashName = signatureAlgorithmHashFromCertificate(peerCert);
        if (hashName === 'MD5' || hashName === 'SHA-1') hashName = 'SHA-256';
        const certHash = await crypto.hashByName(hashName, peerCert);
        const bindingData = Buffer.concat([
            Buffer.from('p=tls-server-end-point,,'),
            Buffer.from(certHash)
        ]);
        channelBinding = bindingData.toString('base64');
    }
    const clientFinalMessageWithoutProof = 'c=' + channelBinding + ',r=' + sv.nonce;
    const authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, 'base64');
    const saltedPassword = await crypto.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto.hmacSha256(saltedPassword, 'Client Key');
    const storedKey = await crypto.sha256(clientKey);
    const clientSignature = await crypto.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString('base64');
    const serverKey = await crypto.hmacSha256(saltedPassword, 'Server Key');
    const serverSignatureBytes = await crypto.hmacSha256(serverKey, authMessage);
    session.message = 'SASLResponse';
    session.serverSignature = Buffer.from(serverSignatureBytes).toString('base64');
    session.response = clientFinalMessageWithoutProof + ',p=' + clientProof;
}
function finalizeSession(session, serverData) {
    if (session.message !== 'SASLResponse') {
        throw new Error('SASL: Last message was not SASLResponse');
    }
    if (typeof serverData !== 'string') {
        throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string');
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
        throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match');
    }
}
/**
 * printable       = %x21-2B / %x2D-7E
 *                   ;; Printable ASCII except ",".
 *                   ;; Note that any "printable" is also
 *                   ;; a valid "value".
 */ function isPrintableChars(text) {
    if (typeof text !== 'string') {
        throw new TypeError('SASL: text must be a string');
    }
    return text.split('').map((_, i)=>text.charCodeAt(i)).every((c)=>c >= 0x21 && c <= 0x2b || c >= 0x2d && c <= 0x7e);
}
/**
 * base64-char     = ALPHA / DIGIT / "/" / "+"
 *
 * base64-4        = 4base64-char
 *
 * base64-3        = 3base64-char "="
 *
 * base64-2        = 2base64-char "=="
 *
 * base64          = *base64-4 [base64-3 / base64-2]
 */ function isBase64(text) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
}
function parseAttributePairs(text) {
    if (typeof text !== 'string') {
        throw new TypeError('SASL: attribute pairs text must be a string');
    }
    return new Map(text.split(',').map((attrValue)=>{
        if (!/^.=/.test(attrValue)) {
            throw new Error('SASL: Invalid attribute pair entry');
        }
        const name = attrValue[0];
        const value = attrValue.substring(2);
        return [
            name,
            value
        ];
    }));
}
function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get('r');
    if (!nonce) {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing');
    } else if (!isPrintableChars(nonce)) {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters');
    }
    const salt = attrPairs.get('s');
    if (!salt) {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing');
    } else if (!isBase64(salt)) {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64');
    }
    const iterationText = attrPairs.get('i');
    if (!iterationText) {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing');
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
        throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count');
    }
    const iteration = parseInt(iterationText, 10);
    return {
        nonce,
        salt,
        iteration
    };
}
function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get('v');
    if (!serverSignature) {
        throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing');
    } else if (!isBase64(serverSignature)) {
        throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64');
    }
    return {
        serverSignature
    };
}
function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
        throw new TypeError('first argument must be a Buffer');
    }
    if (!Buffer.isBuffer(b)) {
        throw new TypeError('second argument must be a Buffer');
    }
    if (a.length !== b.length) {
        throw new Error('Buffer lengths must match');
    }
    if (a.length === 0) {
        throw new Error('Buffers cannot be empty');
    }
    return Buffer.from(a.map((_, i)=>a[i] ^ b[i]));
}
module.exports = {
    startSession,
    continueSession,
    finalizeSession
};
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/type-overrides.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const types = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js [app-route] (ecmascript)");
function TypeOverrides(userTypes) {
    this._types = userTypes || types;
    this.text = {};
    this.binary = {};
}
TypeOverrides.prototype.getOverrides = function(format) {
    switch(format){
        case 'text':
            return this.text;
        case 'binary':
            return this.binary;
        default:
            return {};
    }
};
TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === 'function') {
        parseFn = format;
        format = 'text';
    }
    this.getOverrides(format)[oid] = parseFn;
};
TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || 'text';
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
};
module.exports = TypeOverrides;
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/connection-parameters.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const dns = __turbopack_context__.r("[externals]/dns [external] (dns, cjs)");
const defaults = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/defaults.js [app-route] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-connection-string@2.11.0/node_modules/pg-connection-string/index.js [app-route] (ecmascript)").parse // parses a connection string
;
const val = function(key, config, envVar) {
    if (config[key]) {
        return config[key];
    }
    if (envVar === undefined) {
        envVar = process.env['PG' + key.toUpperCase()];
    } else if (envVar === false) {
    // do nothing ... use false
    } else {
        envVar = process.env[envVar];
    }
    return envVar || defaults[key];
};
const readSSLConfigFromEnvironment = function() {
    switch(process.env.PGSSLMODE){
        case 'disable':
            return false;
        case 'prefer':
        case 'require':
        case 'verify-ca':
        case 'verify-full':
            return true;
        case 'no-verify':
            return {
                rejectUnauthorized: false
            };
    }
    return defaults.ssl;
};
// Convert arg to a string, surround in single quotes, and escape single quotes and backslashes
const quoteParamValue = function(value) {
    return "'" + ('' + value).replace(/\\/g, '\\\\').replace(/'/g, "\\'") + "'";
};
const add = function(params, config, paramName) {
    const value = config[paramName];
    if (value !== undefined && value !== null) {
        params.push(paramName + '=' + quoteParamValue(value));
    }
};
class ConnectionParameters {
    constructor(config){
        // if a string is passed, it is a raw connection string so we parse it into a config
        config = typeof config === 'string' ? parse(config) : config || {};
        // if the config has a connectionString defined, parse IT into the config we use
        // this will override other default values with what is stored in connectionString
        if (config.connectionString) {
            config = Object.assign({}, config, parse(config.connectionString));
        }
        this.user = val('user', config);
        this.database = val('database', config);
        if (this.database === undefined) {
            this.database = this.user;
        }
        this.port = parseInt(val('port', config), 10);
        this.host = val('host', config);
        // "hiding" the password so it doesn't show up in stack traces
        // or if the client is console.logged
        Object.defineProperty(this, 'password', {
            configurable: true,
            enumerable: false,
            writable: true,
            value: val('password', config)
        });
        this.binary = val('binary', config);
        this.options = val('options', config);
        this.ssl = typeof config.ssl === 'undefined' ? readSSLConfigFromEnvironment() : config.ssl;
        if (typeof this.ssl === 'string') {
            if (this.ssl === 'true') {
                this.ssl = true;
            }
        }
        // support passing in ssl=no-verify via connection string
        if (this.ssl === 'no-verify') {
            this.ssl = {
                rejectUnauthorized: false
            };
        }
        if (this.ssl && this.ssl.key) {
            Object.defineProperty(this.ssl, 'key', {
                enumerable: false
            });
        }
        this.client_encoding = val('client_encoding', config);
        this.replication = val('replication', config);
        // a domain socket begins with '/'
        this.isDomainSocket = !(this.host || '').indexOf('/');
        this.application_name = val('application_name', config, 'PGAPPNAME');
        this.fallback_application_name = val('fallback_application_name', config, false);
        this.statement_timeout = val('statement_timeout', config, false);
        this.lock_timeout = val('lock_timeout', config, false);
        this.idle_in_transaction_session_timeout = val('idle_in_transaction_session_timeout', config, false);
        this.query_timeout = val('query_timeout', config, false);
        if (config.connectionTimeoutMillis === undefined) {
            this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
        } else {
            this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
        }
        if (config.keepAlive === false) {
            this.keepalives = 0;
        } else if (config.keepAlive === true) {
            this.keepalives = 1;
        }
        if (typeof config.keepAliveInitialDelayMillis === 'number') {
            this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
        }
    }
    getLibpqConnectionString(cb) {
        const params = [];
        add(params, this, 'user');
        add(params, this, 'password');
        add(params, this, 'port');
        add(params, this, 'application_name');
        add(params, this, 'fallback_application_name');
        add(params, this, 'connect_timeout');
        add(params, this, 'options');
        const ssl = typeof this.ssl === 'object' ? this.ssl : this.ssl ? {
            sslmode: this.ssl
        } : {};
        add(params, ssl, 'sslmode');
        add(params, ssl, 'sslca');
        add(params, ssl, 'sslkey');
        add(params, ssl, 'sslcert');
        add(params, ssl, 'sslrootcert');
        if (this.database) {
            params.push('dbname=' + quoteParamValue(this.database));
        }
        if (this.replication) {
            params.push('replication=' + quoteParamValue(this.replication));
        }
        if (this.host) {
            params.push('host=' + quoteParamValue(this.host));
        }
        if (this.isDomainSocket) {
            return cb(null, params.join(' '));
        }
        if (this.client_encoding) {
            params.push('client_encoding=' + quoteParamValue(this.client_encoding));
        }
        dns.lookup(this.host, function(err, address) {
            if (err) return cb(err, null);
            params.push('hostaddr=' + quoteParamValue(address));
            return cb(null, params.join(' '));
        });
    }
}
module.exports = ConnectionParameters;
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/result.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const types = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js [app-route] (ecmascript)");
const matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;
// result object returned from query
// in the 'end' event and also
// passed as second argument to provided callback
class Result {
    constructor(rowMode, types){
        this.command = null;
        this.rowCount = null;
        this.oid = null;
        this.rows = [];
        this.fields = [];
        this._parsers = undefined;
        this._types = types;
        this.RowCtor = null;
        this.rowAsArray = rowMode === 'array';
        if (this.rowAsArray) {
            this.parseRow = this._parseRowAsArray;
        }
        this._prebuiltEmptyResultObject = null;
    }
    // adds a command complete message
    addCommandComplete(msg) {
        let match;
        if (msg.text) {
            // pure javascript
            match = matchRegexp.exec(msg.text);
        } else {
            // native bindings
            match = matchRegexp.exec(msg.command);
        }
        if (match) {
            this.command = match[1];
            if (match[3]) {
                // COMMAND OID ROWS
                this.oid = parseInt(match[2], 10);
                this.rowCount = parseInt(match[3], 10);
            } else if (match[2]) {
                // COMMAND ROWS
                this.rowCount = parseInt(match[2], 10);
            }
        }
    }
    _parseRowAsArray(rowData) {
        const row = new Array(rowData.length);
        for(let i = 0, len = rowData.length; i < len; i++){
            const rawValue = rowData[i];
            if (rawValue !== null) {
                row[i] = this._parsers[i](rawValue);
            } else {
                row[i] = null;
            }
        }
        return row;
    }
    parseRow(rowData) {
        const row = {
            ...this._prebuiltEmptyResultObject
        };
        for(let i = 0, len = rowData.length; i < len; i++){
            const rawValue = rowData[i];
            const field = this.fields[i].name;
            if (rawValue !== null) {
                const v = this.fields[i].format === 'binary' ? Buffer.from(rawValue) : rawValue;
                row[field] = this._parsers[i](v);
            } else {
                row[field] = null;
            }
        }
        return row;
    }
    addRow(row) {
        this.rows.push(row);
    }
    addFields(fieldDescriptions) {
        // clears field definitions
        // multiple query statements in 1 action can result in multiple sets
        // of rowDescriptions...eg: 'select NOW(); select 1::int;'
        // you need to reset the fields
        this.fields = fieldDescriptions;
        if (this.fields.length) {
            this._parsers = new Array(fieldDescriptions.length);
        }
        const row = {};
        for(let i = 0; i < fieldDescriptions.length; i++){
            const desc = fieldDescriptions[i];
            row[desc.name] = null;
            if (this._types) {
                this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || 'text');
            } else {
                this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || 'text');
            }
        }
        this._prebuiltEmptyResultObject = {
            ...row
        };
    }
}
module.exports = Result;
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { EventEmitter } = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const Result = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/result.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/utils.js [app-route] (ecmascript)");
class Query extends EventEmitter {
    constructor(config, values, callback){
        super();
        config = utils.normalizeQueryConfig(config, values, callback);
        this.text = config.text;
        this.values = config.values;
        this.rows = config.rows;
        this.types = config.types;
        this.name = config.name;
        this.queryMode = config.queryMode;
        this.binary = config.binary;
        // use unique portal name each time
        this.portal = config.portal || '';
        this.callback = config.callback;
        this._rowMode = config.rowMode;
        if (process.domain && config.callback) {
            this.callback = process.domain.bind(config.callback);
        }
        this._result = new Result(this._rowMode, this.types);
        // potential for multiple results
        this._results = this._result;
        this._canceledDueToError = false;
    }
    requiresPreparation() {
        if (this.queryMode === 'extended') {
            return true;
        }
        // named queries must always be prepared
        if (this.name) {
            return true;
        }
        // always prepare if there are max number of rows expected per
        // portal execution
        if (this.rows) {
            return true;
        }
        // don't prepare empty text queries
        if (!this.text) {
            return false;
        }
        // prepare if there are values
        if (!this.values) {
            return false;
        }
        return this.values.length > 0;
    }
    _checkForMultirow() {
        // if we already have a result with a command property
        // then we've already executed one query in a multi-statement simple query
        // turn our results into an array of results
        if (this._result.command) {
            if (!Array.isArray(this._results)) {
                this._results = [
                    this._result
                ];
            }
            this._result = new Result(this._rowMode, this._result._types);
            this._results.push(this._result);
        }
    }
    // associates row metadata from the supplied
    // message with this query object
    // metadata used when parsing row results
    handleRowDescription(msg) {
        this._checkForMultirow();
        this._result.addFields(msg.fields);
        this._accumulateRows = this.callback || !this.listeners('row').length;
    }
    handleDataRow(msg) {
        let row;
        if (this._canceledDueToError) {
            return;
        }
        try {
            row = this._result.parseRow(msg.fields);
        } catch (err) {
            this._canceledDueToError = err;
            return;
        }
        this.emit('row', row, this._result);
        if (this._accumulateRows) {
            this._result.addRow(row);
        }
    }
    handleCommandComplete(msg, connection) {
        this._checkForMultirow();
        this._result.addCommandComplete(msg);
        // need to sync after each command complete of a prepared statement
        // if we were using a row count which results in multiple calls to _getRows
        if (this.rows) {
            connection.sync();
        }
    }
    // if a named prepared statement is created with empty query text
    // the backend will send an emptyQuery message but *not* a command complete message
    // since we pipeline sync immediately after execute we don't need to do anything here
    // unless we have rows specified, in which case we did not pipeline the initial sync call
    handleEmptyQuery(connection) {
        if (this.rows) {
            connection.sync();
        }
    }
    handleError(err, connection) {
        // need to sync after error during a prepared statement
        if (this._canceledDueToError) {
            err = this._canceledDueToError;
            this._canceledDueToError = false;
        }
        // if callback supplied do not emit error event as uncaught error
        // events will bubble up to node process
        if (this.callback) {
            return this.callback(err);
        }
        this.emit('error', err);
    }
    handleReadyForQuery(con) {
        if (this._canceledDueToError) {
            return this.handleError(this._canceledDueToError, con);
        }
        if (this.callback) {
            try {
                this.callback(null, this._results);
            } catch (err) {
                process.nextTick(()=>{
                    throw err;
                });
            }
        }
        this.emit('end', this._results);
    }
    submit(connection) {
        if (typeof this.text !== 'string' && typeof this.name !== 'string') {
            return new Error('A query must have either text or a name. Supplying neither is unsupported.');
        }
        const previous = connection.parsedStatements[this.name];
        if (this.text && previous && this.text !== previous) {
            return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
        }
        if (this.values && !Array.isArray(this.values)) {
            return new Error('Query values must be an array');
        }
        if (this.requiresPreparation()) {
            // If we're using the extended query protocol we fire off several separate commands
            // to the backend. On some versions of node & some operating system versions
            // the network stack writes each message separately instead of buffering them together
            // causing the client & network to send more slowly. Corking & uncorking the stream
            // allows node to buffer up the messages internally before sending them all off at once.
            // note: we're checking for existence of cork/uncork because some versions of streams
            // might not have this (cloudflare?)
            connection.stream.cork && connection.stream.cork();
            try {
                this.prepare(connection);
            } finally{
                // while unlikely for this.prepare to throw, if it does & we don't uncork this stream
                // this client becomes unresponsive, so put in finally block "just in case"
                connection.stream.uncork && connection.stream.uncork();
            }
        } else {
            connection.query(this.text);
        }
        return null;
    }
    hasBeenParsed(connection) {
        return this.name && connection.parsedStatements[this.name];
    }
    handlePortalSuspended(connection) {
        this._getRows(connection, this.rows);
    }
    _getRows(connection, rows) {
        connection.execute({
            portal: this.portal,
            rows: rows
        });
        // if we're not reading pages of rows send the sync command
        // to indicate the pipeline is finished
        if (!rows) {
            connection.sync();
        } else {
            // otherwise flush the call out to read more rows
            connection.flush();
        }
    }
    // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
    prepare(connection) {
        // TODO refactor this poor encapsulation
        if (!this.hasBeenParsed(connection)) {
            connection.parse({
                text: this.text,
                name: this.name,
                types: this.types
            });
        }
        // because we're mapping user supplied values to
        // postgres wire protocol compatible values it could
        // throw an exception, so try/catch this section
        try {
            connection.bind({
                portal: this.portal,
                statement: this.name,
                values: this.values,
                binary: this.binary,
                valueMapper: utils.prepareValue
            });
        } catch (err) {
            this.handleError(err, connection);
            return;
        }
        connection.describe({
            type: 'P',
            name: this.portal || ''
        });
        this._getRows(connection, this.rows);
    }
    handleCopyInResponse(connection) {
        connection.sendCopyFail('No source stream defined');
    }
    handleCopyData(msg, connection) {
    // noop
    }
}
module.exports = Query;
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const { getStream, getSecureStream } = getStreamFuncs();
module.exports = {
    /**
   * Get a socket stream compatible with the current runtime environment.
   * @returns {Duplex}
   */ getStream,
    /**
   * Get a TLS secured socket, compatible with the current environment,
   * using the socket and other settings given in `options`.
   * @returns {Duplex}
   */ getSecureStream
};
/**
 * The stream functions that work in Node.js
 */ function getNodejsStreamFuncs() {
    function getStream(ssl) {
        const net = __turbopack_context__.r("[externals]/net [external] (net, cjs)");
        return new net.Socket();
    }
    function getSecureStream(options) {
        const tls = __turbopack_context__.r("[externals]/tls [external] (tls, cjs)");
        return tls.connect(options);
    }
    return {
        getStream,
        getSecureStream
    };
}
/**
 * The stream functions that work in Cloudflare Workers
 */ function getCloudflareStreamFuncs() {
    function getStream(ssl) {
        const { CloudflareSocket } = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-cloudflare@1.3.0/node_modules/pg-cloudflare/dist/empty.js [app-route] (ecmascript)");
        return new CloudflareSocket(ssl);
    }
    function getSecureStream(options) {
        options.socket.startTls(options);
        return options.socket;
    }
    return {
        getStream,
        getSecureStream
    };
}
/**
 * Are we running in a Cloudflare Worker?
 *
 * @returns true if the code is currently running inside a Cloudflare Worker.
 */ function isCloudflareRuntime() {
    // Since 2022-03-21 the `global_navigator` compatibility flag is on for Cloudflare Workers
    // which means that `navigator.userAgent` will be defined.
    // eslint-disable-next-line no-undef
    if (typeof navigator === 'object' && navigator !== null && typeof navigator.userAgent === 'string') {
        // eslint-disable-next-line no-undef
        return navigator.userAgent === 'Cloudflare-Workers';
    }
    // In case `navigator` or `navigator.userAgent` is not defined then try a more sneaky approach
    if (typeof Response === 'function') {
        const resp = new Response(null, {
            cf: {
                thing: true
            }
        });
        if (typeof resp.cf === 'object' && resp.cf !== null && resp.cf.thing) {
            return true;
        }
    }
    return false;
}
function getStreamFuncs() {
    if (isCloudflareRuntime()) {
        return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
}
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/connection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)").EventEmitter;
const { parse, serialize } = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/index.js [app-route] (ecmascript)");
const { getStream, getSecureStream } = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/stream.js [app-route] (ecmascript)");
const flushBuffer = serialize.flush();
const syncBuffer = serialize.sync();
const endBuffer = serialize.end();
// TODO(bmc) support binary mode at some point
class Connection extends EventEmitter {
    constructor(config){
        super();
        config = config || {};
        this.stream = config.stream || getStream(config.ssl);
        if (typeof this.stream === 'function') {
            this.stream = this.stream(config);
        }
        this._keepAlive = config.keepAlive;
        this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
        this.parsedStatements = {};
        this.ssl = config.ssl || false;
        this._ending = false;
        this._emitMessage = false;
        const self = this;
        this.on('newListener', function(eventName) {
            if (eventName === 'message') {
                self._emitMessage = true;
            }
        });
    }
    connect(port, host) {
        const self = this;
        this._connecting = true;
        this.stream.setNoDelay(true);
        this.stream.connect(port, host);
        this.stream.once('connect', function() {
            if (self._keepAlive) {
                self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);
            }
            self.emit('connect');
        });
        const reportStreamError = function(error) {
            // errors about disconnections should be ignored during disconnect
            if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {
                return;
            }
            self.emit('error', error);
        };
        this.stream.on('error', reportStreamError);
        this.stream.on('close', function() {
            self.emit('end');
        });
        if (!this.ssl) {
            return this.attachListeners(this.stream);
        }
        this.stream.once('data', function(buffer) {
            const responseCode = buffer.toString('utf8');
            switch(responseCode){
                case 'S':
                    break;
                case 'N':
                    self.stream.end();
                    return self.emit('error', new Error('The server does not support SSL connections'));
                default:
                    // Any other response byte, including 'E' (ErrorResponse) indicating a server error
                    self.stream.end();
                    return self.emit('error', new Error('There was an error establishing an SSL connection'));
            }
            const options = {
                socket: self.stream
            };
            if (self.ssl !== true) {
                Object.assign(options, self.ssl);
                if ('key' in self.ssl) {
                    options.key = self.ssl.key;
                }
            }
            const net = __turbopack_context__.r("[externals]/net [external] (net, cjs)");
            if (net.isIP && net.isIP(host) === 0) {
                options.servername = host;
            }
            try {
                self.stream = getSecureStream(options);
            } catch (err) {
                return self.emit('error', err);
            }
            self.attachListeners(self.stream);
            self.stream.on('error', reportStreamError);
            self.emit('sslconnect');
        });
    }
    attachListeners(stream) {
        parse(stream, (msg)=>{
            const eventName = msg.name === 'error' ? 'errorMessage' : msg.name;
            if (this._emitMessage) {
                this.emit('message', msg);
            }
            this.emit(eventName, msg);
        });
    }
    requestSsl() {
        this.stream.write(serialize.requestSsl());
    }
    startup(config) {
        this.stream.write(serialize.startup(config));
    }
    cancel(processID, secretKey) {
        this._send(serialize.cancel(processID, secretKey));
    }
    password(password) {
        this._send(serialize.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
        this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
        this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
        if (!this.stream.writable) {
            return false;
        }
        return this.stream.write(buffer);
    }
    query(text) {
        this._send(serialize.query(text));
    }
    // send parse message
    parse(query) {
        this._send(serialize.parse(query));
    }
    // send bind message
    bind(config) {
        this._send(serialize.bind(config));
    }
    // send execute message
    execute(config) {
        this._send(serialize.execute(config));
    }
    flush() {
        if (this.stream.writable) {
            this.stream.write(flushBuffer);
        }
    }
    sync() {
        this._ending = true;
        this._send(syncBuffer);
    }
    ref() {
        this.stream.ref();
    }
    unref() {
        this.stream.unref();
    }
    end() {
        // 0x58 = 'X'
        this._ending = true;
        if (!this._connecting || !this.stream.writable) {
            this.stream.end();
            return;
        }
        return this.stream.write(endBuffer, ()=>{
            this.stream.end();
        });
    }
    close(msg) {
        this._send(serialize.close(msg));
    }
    describe(msg) {
        this._send(serialize.describe(msg));
    }
    sendCopyFromChunk(chunk) {
        this._send(serialize.copyData(chunk));
    }
    endCopyFrom() {
        this._send(serialize.copyDone());
    }
    sendCopyFail(msg) {
        this._send(serialize.copyFail(msg));
    }
}
module.exports = Connection;
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)").EventEmitter;
const utils = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/utils.js [app-route] (ecmascript)");
const nodeUtils = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const sasl = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/sasl.js [app-route] (ecmascript)");
const TypeOverrides = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/type-overrides.js [app-route] (ecmascript)");
const ConnectionParameters = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/connection-parameters.js [app-route] (ecmascript)");
const Query = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/query.js [app-route] (ecmascript)");
const defaults = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/defaults.js [app-route] (ecmascript)");
const Connection = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/connection.js [app-route] (ecmascript)");
const crypto = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/crypto/utils.js [app-route] (ecmascript)");
const activeQueryDeprecationNotice = nodeUtils.deprecate(()=>{}, 'Client.activeQuery is deprecated and will be removed in a future version.');
const queryQueueDeprecationNotice = nodeUtils.deprecate(()=>{}, 'Client.queryQueue is deprecated and will be removed in a future version.');
const pgPassDeprecationNotice = nodeUtils.deprecate(()=>{}, 'pgpass support is deprecated and will be removed in a future version. ' + 'You can provide an async function as the password property to the Client/Pool constructor that returns a password instead. Within this funciton you can call the pgpass module in your own code.');
const byoPromiseDeprecationNotice = nodeUtils.deprecate(()=>{}, 'Passing a custom Promise implementation to the Client/Pool constructor is deprecated and will be removed in a future version.');
class Client extends EventEmitter {
    constructor(config){
        super();
        this.connectionParameters = new ConnectionParameters(config);
        this.user = this.connectionParameters.user;
        this.database = this.connectionParameters.database;
        this.port = this.connectionParameters.port;
        this.host = this.connectionParameters.host;
        // "hiding" the password so it doesn't show up in stack traces
        // or if the client is console.logged
        Object.defineProperty(this, 'password', {
            configurable: true,
            enumerable: false,
            writable: true,
            value: this.connectionParameters.password
        });
        this.replication = this.connectionParameters.replication;
        const c = config || {};
        if (c.Promise) {
            byoPromiseDeprecationNotice();
        }
        this._Promise = c.Promise || /*TURBOPACK member replacement*/ __turbopack_context__.g.Promise;
        this._types = new TypeOverrides(c.types);
        this._ending = false;
        this._ended = false;
        this._connecting = false;
        this._connected = false;
        this._connectionError = false;
        this._queryable = true;
        this._activeQuery = null;
        this.enableChannelBinding = Boolean(c.enableChannelBinding); // set true to use SCRAM-SHA-256-PLUS when offered
        this.connection = c.connection || new Connection({
            stream: c.stream,
            ssl: this.connectionParameters.ssl,
            keepAlive: c.keepAlive || false,
            keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
            encoding: this.connectionParameters.client_encoding || 'utf8'
        });
        this._queryQueue = [];
        this.binary = c.binary || defaults.binary;
        this.processID = null;
        this.secretKey = null;
        this.ssl = this.connectionParameters.ssl || false;
        // As with Password, make SSL->Key (the private key) non-enumerable.
        // It won't show up in stack traces
        // or if the client is console.logged
        if (this.ssl && this.ssl.key) {
            Object.defineProperty(this.ssl, 'key', {
                enumerable: false
            });
        }
        this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    get activeQuery() {
        activeQueryDeprecationNotice();
        return this._activeQuery;
    }
    set activeQuery(val) {
        activeQueryDeprecationNotice();
        this._activeQuery = val;
    }
    _getActiveQuery() {
        return this._activeQuery;
    }
    _errorAllQueries(err) {
        const enqueueError = (query)=>{
            process.nextTick(()=>{
                query.handleError(err, this.connection);
            });
        };
        const activeQuery = this._getActiveQuery();
        if (activeQuery) {
            enqueueError(activeQuery);
            this._activeQuery = null;
        }
        this._queryQueue.forEach(enqueueError);
        this._queryQueue.length = 0;
    }
    _connect(callback) {
        const self = this;
        const con = this.connection;
        this._connectionCallback = callback;
        if (this._connecting || this._connected) {
            const err = new Error('Client has already been connected. You cannot reuse a client.');
            process.nextTick(()=>{
                callback(err);
            });
            return;
        }
        this._connecting = true;
        if (this._connectionTimeoutMillis > 0) {
            this.connectionTimeoutHandle = setTimeout(()=>{
                con._ending = true;
                con.stream.destroy(new Error('timeout expired'));
            }, this._connectionTimeoutMillis);
            if (this.connectionTimeoutHandle.unref) {
                this.connectionTimeoutHandle.unref();
            }
        }
        if (this.host && this.host.indexOf('/') === 0) {
            con.connect(this.host + '/.s.PGSQL.' + this.port);
        } else {
            con.connect(this.port, this.host);
        }
        // once connection is established send startup message
        con.on('connect', function() {
            if (self.ssl) {
                con.requestSsl();
            } else {
                con.startup(self.getStartupConf());
            }
        });
        con.on('sslconnect', function() {
            con.startup(self.getStartupConf());
        });
        this._attachListeners(con);
        con.once('end', ()=>{
            const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly');
            clearTimeout(this.connectionTimeoutHandle);
            this._errorAllQueries(error);
            this._ended = true;
            if (!this._ending) {
                // if the connection is ended without us calling .end()
                // on this client then we have an unexpected disconnection
                // treat this as an error unless we've already emitted an error
                // during connection.
                if (this._connecting && !this._connectionError) {
                    if (this._connectionCallback) {
                        this._connectionCallback(error);
                    } else {
                        this._handleErrorEvent(error);
                    }
                } else if (!this._connectionError) {
                    this._handleErrorEvent(error);
                }
            }
            process.nextTick(()=>{
                this.emit('end');
            });
        });
    }
    connect(callback) {
        if (callback) {
            this._connect(callback);
            return;
        }
        return new this._Promise((resolve, reject)=>{
            this._connect((error)=>{
                if (error) {
                    reject(error);
                } else {
                    resolve(this);
                }
            });
        });
    }
    _attachListeners(con) {
        // password request handling
        con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this));
        // password request handling
        con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this));
        // password request handling (SASL)
        con.on('authenticationSASL', this._handleAuthSASL.bind(this));
        con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this));
        con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this));
        con.on('backendKeyData', this._handleBackendKeyData.bind(this));
        con.on('error', this._handleErrorEvent.bind(this));
        con.on('errorMessage', this._handleErrorMessage.bind(this));
        con.on('readyForQuery', this._handleReadyForQuery.bind(this));
        con.on('notice', this._handleNotice.bind(this));
        con.on('rowDescription', this._handleRowDescription.bind(this));
        con.on('dataRow', this._handleDataRow.bind(this));
        con.on('portalSuspended', this._handlePortalSuspended.bind(this));
        con.on('emptyQuery', this._handleEmptyQuery.bind(this));
        con.on('commandComplete', this._handleCommandComplete.bind(this));
        con.on('parseComplete', this._handleParseComplete.bind(this));
        con.on('copyInResponse', this._handleCopyInResponse.bind(this));
        con.on('copyData', this._handleCopyData.bind(this));
        con.on('notification', this._handleNotification.bind(this));
    }
    _getPassword(cb) {
        const con = this.connection;
        if (typeof this.password === 'function') {
            this._Promise.resolve().then(()=>this.password()).then((pass)=>{
                if (pass !== undefined) {
                    if (typeof pass !== 'string') {
                        con.emit('error', new TypeError('Password must be a string'));
                        return;
                    }
                    this.connectionParameters.password = this.password = pass;
                } else {
                    this.connectionParameters.password = this.password = null;
                }
                cb();
            }).catch((err)=>{
                con.emit('error', err);
            });
        } else if (this.password !== null) {
            cb();
        } else {
            try {
                const pgPass = __turbopack_context__.r("[project]/node_modules/.pnpm/pgpass@1.0.5/node_modules/pgpass/lib/index.js [app-route] (ecmascript)");
                pgPass(this.connectionParameters, (pass)=>{
                    if (undefined !== pass) {
                        pgPassDeprecationNotice();
                        this.connectionParameters.password = this.password = pass;
                    }
                    cb();
                });
            } catch (e) {
                this.emit('error', e);
            }
        }
    }
    _handleAuthCleartextPassword(msg) {
        this._getPassword(()=>{
            this.connection.password(this.password);
        });
    }
    _handleAuthMD5Password(msg) {
        this._getPassword(async ()=>{
            try {
                const hashedPassword = await crypto.postgresMd5PasswordHash(this.user, this.password, msg.salt);
                this.connection.password(hashedPassword);
            } catch (e) {
                this.emit('error', e);
            }
        });
    }
    _handleAuthSASL(msg) {
        this._getPassword(()=>{
            try {
                this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
                this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
            } catch (err) {
                this.connection.emit('error', err);
            }
        });
    }
    async _handleAuthSASLContinue(msg) {
        try {
            await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
            this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
        } catch (err) {
            this.connection.emit('error', err);
        }
    }
    _handleAuthSASLFinal(msg) {
        try {
            sasl.finalizeSession(this.saslSession, msg.data);
            this.saslSession = null;
        } catch (err) {
            this.connection.emit('error', err);
        }
    }
    _handleBackendKeyData(msg) {
        this.processID = msg.processID;
        this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
        if (this._connecting) {
            this._connecting = false;
            this._connected = true;
            clearTimeout(this.connectionTimeoutHandle);
            // process possible callback argument to Client#connect
            if (this._connectionCallback) {
                this._connectionCallback(null, this);
                // remove callback for proper error handling
                // after the connect event
                this._connectionCallback = null;
            }
            this.emit('connect');
        }
        const activeQuery = this._getActiveQuery();
        this._activeQuery = null;
        this.readyForQuery = true;
        if (activeQuery) {
            activeQuery.handleReadyForQuery(this.connection);
        }
        this._pulseQueryQueue();
    }
    // if we receive an error event or error message
    // during the connection process we handle it here
    _handleErrorWhileConnecting(err) {
        if (this._connectionError) {
            // TODO(bmc): this is swallowing errors - we shouldn't do this
            return;
        }
        this._connectionError = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
            return this._connectionCallback(err);
        }
        this.emit('error', err);
    }
    // if we're connected and we receive an error event from the connection
    // this means the socket is dead - do a hard abort of all queries and emit
    // the socket error on the client as well
    _handleErrorEvent(err) {
        if (this._connecting) {
            return this._handleErrorWhileConnecting(err);
        }
        this._queryable = false;
        this._errorAllQueries(err);
        this.emit('error', err);
    }
    // handle error messages from the postgres backend
    _handleErrorMessage(msg) {
        if (this._connecting) {
            return this._handleErrorWhileConnecting(msg);
        }
        const activeQuery = this._getActiveQuery();
        if (!activeQuery) {
            this._handleErrorEvent(msg);
            return;
        }
        this._activeQuery = null;
        activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
        const activeQuery = this._getActiveQuery();
        if (activeQuery == null) {
            const error = new Error('Received unexpected rowDescription message from backend.');
            this._handleErrorEvent(error);
            return;
        }
        // delegate rowDescription to active query
        activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
        const activeQuery = this._getActiveQuery();
        if (activeQuery == null) {
            const error = new Error('Received unexpected dataRow message from backend.');
            this._handleErrorEvent(error);
            return;
        }
        // delegate dataRow to active query
        activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
        const activeQuery = this._getActiveQuery();
        if (activeQuery == null) {
            const error = new Error('Received unexpected portalSuspended message from backend.');
            this._handleErrorEvent(error);
            return;
        }
        // delegate portalSuspended to active query
        activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
        const activeQuery = this._getActiveQuery();
        if (activeQuery == null) {
            const error = new Error('Received unexpected emptyQuery message from backend.');
            this._handleErrorEvent(error);
            return;
        }
        // delegate emptyQuery to active query
        activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
        const activeQuery = this._getActiveQuery();
        if (activeQuery == null) {
            const error = new Error('Received unexpected commandComplete message from backend.');
            this._handleErrorEvent(error);
            return;
        }
        // delegate commandComplete to active query
        activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
        const activeQuery = this._getActiveQuery();
        if (activeQuery == null) {
            const error = new Error('Received unexpected parseComplete message from backend.');
            this._handleErrorEvent(error);
            return;
        }
        // if a prepared statement has a name and properly parses
        // we track that its already been executed so we don't parse
        // it again on the same client
        if (activeQuery.name) {
            this.connection.parsedStatements[activeQuery.name] = activeQuery.text;
        }
    }
    _handleCopyInResponse(msg) {
        const activeQuery = this._getActiveQuery();
        if (activeQuery == null) {
            const error = new Error('Received unexpected copyInResponse message from backend.');
            this._handleErrorEvent(error);
            return;
        }
        activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
        const activeQuery = this._getActiveQuery();
        if (activeQuery == null) {
            const error = new Error('Received unexpected copyData message from backend.');
            this._handleErrorEvent(error);
            return;
        }
        activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
        this.emit('notification', msg);
    }
    _handleNotice(msg) {
        this.emit('notice', msg);
    }
    getStartupConf() {
        const params = this.connectionParameters;
        const data = {
            user: params.user,
            database: params.database
        };
        const appName = params.application_name || params.fallback_application_name;
        if (appName) {
            data.application_name = appName;
        }
        if (params.replication) {
            data.replication = '' + params.replication;
        }
        if (params.statement_timeout) {
            data.statement_timeout = String(parseInt(params.statement_timeout, 10));
        }
        if (params.lock_timeout) {
            data.lock_timeout = String(parseInt(params.lock_timeout, 10));
        }
        if (params.idle_in_transaction_session_timeout) {
            data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
        }
        if (params.options) {
            data.options = params.options;
        }
        return data;
    }
    cancel(client, query) {
        if (client.activeQuery === query) {
            const con = this.connection;
            if (this.host && this.host.indexOf('/') === 0) {
                con.connect(this.host + '/.s.PGSQL.' + this.port);
            } else {
                con.connect(this.port, this.host);
            }
            // once connection is established send cancel message
            con.on('connect', function() {
                con.cancel(client.processID, client.secretKey);
            });
        } else if (client._queryQueue.indexOf(query) !== -1) {
            client._queryQueue.splice(client._queryQueue.indexOf(query), 1);
        }
    }
    setTypeParser(oid, format, parseFn) {
        return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
        return this._types.getTypeParser(oid, format);
    }
    // escapeIdentifier and escapeLiteral moved to utility functions & exported
    // on PG
    // re-exported here for backwards compatibility
    escapeIdentifier(str) {
        return utils.escapeIdentifier(str);
    }
    escapeLiteral(str) {
        return utils.escapeLiteral(str);
    }
    _pulseQueryQueue() {
        if (this.readyForQuery === true) {
            this._activeQuery = this._queryQueue.shift();
            const activeQuery = this._getActiveQuery();
            if (activeQuery) {
                this.readyForQuery = false;
                this.hasExecuted = true;
                const queryError = activeQuery.submit(this.connection);
                if (queryError) {
                    process.nextTick(()=>{
                        activeQuery.handleError(queryError, this.connection);
                        this.readyForQuery = true;
                        this._pulseQueryQueue();
                    });
                }
            } else if (this.hasExecuted) {
                this._activeQuery = null;
                this.emit('drain');
            }
        }
    }
    query(config, values, callback) {
        // can take in strings, config object or query object
        let query;
        let result;
        let readTimeout;
        let readTimeoutTimer;
        let queryCallback;
        if (config === null || config === undefined) {
            throw new TypeError('Client was passed a null or undefined query');
        } else if (typeof config.submit === 'function') {
            readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
            result = query = config;
            if (typeof values === 'function') {
                query.callback = query.callback || values;
            }
        } else {
            readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
            query = new Query(config, values, callback);
            if (!query.callback) {
                result = new this._Promise((resolve, reject)=>{
                    query.callback = (err, res)=>err ? reject(err) : resolve(res);
                }).catch((err)=>{
                    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the
                    // application that created the query
                    Error.captureStackTrace(err);
                    throw err;
                });
            }
        }
        if (readTimeout) {
            queryCallback = query.callback;
            readTimeoutTimer = setTimeout(()=>{
                const error = new Error('Query read timeout');
                process.nextTick(()=>{
                    query.handleError(error, this.connection);
                });
                queryCallback(error);
                // we already returned an error,
                // just do nothing if query completes
                query.callback = ()=>{};
                // Remove from queue
                const index = this._queryQueue.indexOf(query);
                if (index > -1) {
                    this._queryQueue.splice(index, 1);
                }
                this._pulseQueryQueue();
            }, readTimeout);
            query.callback = (err, res)=>{
                clearTimeout(readTimeoutTimer);
                queryCallback(err, res);
            };
        }
        if (this.binary && !query.binary) {
            query.binary = true;
        }
        if (query._result && !query._result._types) {
            query._result._types = this._types;
        }
        if (!this._queryable) {
            process.nextTick(()=>{
                query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection);
            });
            return result;
        }
        if (this._ending) {
            process.nextTick(()=>{
                query.handleError(new Error('Client was closed and is not queryable'), this.connection);
            });
            return result;
        }
        this._queryQueue.push(query);
        this._pulseQueryQueue();
        return result;
    }
    ref() {
        this.connection.ref();
    }
    unref() {
        this.connection.unref();
    }
    end(cb) {
        this._ending = true;
        // if we have never connected, then end is a noop, callback immediately
        if (!this.connection._connecting || this._ended) {
            if (cb) {
                cb();
            } else {
                return this._Promise.resolve();
            }
        }
        if (this._getActiveQuery() || !this._queryable) {
            // if we have an active query we need to force a disconnect
            // on the socket - otherwise a hung query could block end forever
            this.connection.stream.destroy();
        } else {
            this.connection.end();
        }
        if (cb) {
            this.connection.once('end', cb);
        } else {
            return new this._Promise((resolve)=>{
                this.connection.once('end', resolve);
            });
        }
    }
    get queryQueue() {
        queryQueueDeprecationNotice();
        return this._queryQueue;
    }
}
// expose a Query constructor
Client.Query = Query;
module.exports = Client;
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/native/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)").EventEmitter;
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const utils = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/utils.js [app-route] (ecmascript)");
const NativeQuery = module.exports = function(config, values, callback) {
    EventEmitter.call(this);
    config = utils.normalizeQueryConfig(config, values, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.queryMode = config.queryMode;
    this.callback = config.callback;
    this.state = 'new';
    this._arrayMode = config.rowMode === 'array';
    // if the 'row' event is listened for
    // then emit them as they come in
    // without setting singleRowMode to true
    // this has almost no meaning because libpq
    // reads all rows into memory before returning any
    this._emitRowEvents = false;
    this.on('newListener', (function(event) {
        if (event === 'row') this._emitRowEvents = true;
    }).bind(this));
};
util.inherits(NativeQuery, EventEmitter);
const errorFieldMap = {
    sqlState: 'code',
    statementPosition: 'position',
    messagePrimary: 'message',
    context: 'where',
    schemaName: 'schema',
    tableName: 'table',
    columnName: 'column',
    dataTypeName: 'dataType',
    constraintName: 'constraint',
    sourceFile: 'file',
    sourceLine: 'line',
    sourceFunction: 'routine'
};
NativeQuery.prototype.handleError = function(err) {
    // copy pq error fields into the error object
    const fields = this.native.pq.resultErrorFields();
    if (fields) {
        for(const key in fields){
            const normalizedFieldName = errorFieldMap[key] || key;
            err[normalizedFieldName] = fields[key];
        }
    }
    if (this.callback) {
        this.callback(err);
    } else {
        this.emit('error', err);
    }
    this.state = 'error';
};
NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
};
NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
};
NativeQuery.prototype._getPromise = function() {
    if (this._promise) return this._promise;
    this._promise = new Promise((function(resolve, reject) {
        this._once('end', resolve);
        this._once('error', reject);
    }).bind(this));
    return this._promise;
};
NativeQuery.prototype.submit = function(client) {
    this.state = 'running';
    const self = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    let after = function(err, rows, results) {
        client.native.arrayMode = false;
        setImmediate(function() {
            self.emit('_done');
        });
        // handle possible query error
        if (err) {
            return self.handleError(err);
        }
        // emit row events for each row in the result
        if (self._emitRowEvents) {
            if (results.length > 1) {
                rows.forEach((rowOfRows, i)=>{
                    rowOfRows.forEach((row)=>{
                        self.emit('row', row, results[i]);
                    });
                });
            } else {
                rows.forEach(function(row) {
                    self.emit('row', row, results);
                });
            }
        }
        // handle successful result
        self.state = 'end';
        self.emit('end', results);
        if (self.callback) {
            self.callback(null, results);
        }
    };
    if (process.domain) {
        after = process.domain.bind(after);
    }
    // named query
    if (this.name) {
        if (this.name.length > 63) {
            console.error('Warning! Postgres only supports 63 characters for query names.');
            console.error('You supplied %s (%s)', this.name, this.name.length);
            console.error('This can cause conflicts and silent errors executing queries');
        }
        const values = (this.values || []).map(utils.prepareValue);
        // check if the client has already executed this named query
        // if so...just execute it again - skip the planning phase
        if (client.namedQueries[this.name]) {
            if (this.text && client.namedQueries[this.name] !== this.text) {
                const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
                return after(err);
            }
            return client.native.execute(this.name, values, after);
        }
        // plan the named query the first time, then execute it
        return client.native.prepare(this.name, this.text, values.length, function(err) {
            if (err) return after(err);
            client.namedQueries[self.name] = self.text;
            return self.native.execute(self.name, values, after);
        });
    } else if (this.values) {
        if (!Array.isArray(this.values)) {
            const err = new Error('Query values must be an array');
            return after(err);
        }
        const vals = this.values.map(utils.prepareValue);
        client.native.query(this.text, vals, after);
    } else if (this.queryMode === 'extended') {
        client.native.query(this.text, [], after);
    } else {
        client.native.query(this.text, after);
    }
};
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/native/client.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// eslint-disable-next-line
var Native;
// eslint-disable-next-line no-useless-catch
try {
    // Wrap this `require()` in a try-catch to avoid upstream bundlers from complaining that this might not be available since it is an optional import
    Native = (()=>{
        const e = new Error("Cannot find module 'pg-native'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })();
} catch (e) {
    throw e;
}
const TypeOverrides = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/type-overrides.js [app-route] (ecmascript)");
const EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)").EventEmitter;
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const ConnectionParameters = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/connection-parameters.js [app-route] (ecmascript)");
const NativeQuery = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/native/query.js [app-route] (ecmascript)");
const Client = module.exports = function(config) {
    EventEmitter.call(this);
    config = config || {};
    this._Promise = config.Promise || /*TURBOPACK member replacement*/ __turbopack_context__.g.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
        types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    // keep these on the object for legacy reasons
    // for the time being. TODO: deprecate all this jazz
    const cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString) cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    // "hiding" the password so it doesn't show up in stack traces
    // or if the client is console.logged
    Object.defineProperty(this, 'password', {
        configurable: true,
        enumerable: false,
        writable: true,
        value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    // a hash to hold named queries
    this.namedQueries = {};
};
Client.Query = NativeQuery;
util.inherits(Client, EventEmitter);
Client.prototype._errorAllQueries = function(err) {
    const enqueueError = (query)=>{
        process.nextTick(()=>{
            query.native = this.native;
            query.handleError(err);
        });
    };
    if (this._hasActiveQuery()) {
        enqueueError(this._activeQuery);
        this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
};
// connect to the backend
// pass an optional callback to be called once connected
// or with an error if there was a connection error
Client.prototype._connect = function(cb) {
    const self = this;
    if (this._connecting) {
        process.nextTick(()=>cb(new Error('Client has already been connected. You cannot reuse a client.')));
        return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
        if (self.connectionParameters.nativeConnectionString) conString = self.connectionParameters.nativeConnectionString;
        if (err) return cb(err);
        self.native.connect(conString, function(err) {
            if (err) {
                self.native.end();
                return cb(err);
            }
            // set internal states to connected
            self._connected = true;
            // handle connection errors from the native layer
            self.native.on('error', function(err) {
                self._queryable = false;
                self._errorAllQueries(err);
                self.emit('error', err);
            });
            self.native.on('notification', function(msg) {
                self.emit('notification', {
                    channel: msg.relname,
                    payload: msg.extra
                });
            });
            // signal we are connected now
            self.emit('connect');
            self._pulseQueryQueue(true);
            cb(null, this);
        });
    });
};
Client.prototype.connect = function(callback) {
    if (callback) {
        this._connect(callback);
        return;
    }
    return new this._Promise((resolve, reject)=>{
        this._connect((error)=>{
            if (error) {
                reject(error);
            } else {
                resolve(this);
            }
        });
    });
};
// send a query to the server
// this method is highly overloaded to take
// 1) string query, optional array of parameters, optional function callback
// 2) object query with {
//    string query
//    optional array values,
//    optional function callback instead of as a separate parameter
//    optional string name to name & cache the query plan
//    optional string rowMode = 'array' for an array of results
//  }
Client.prototype.query = function(config, values, callback) {
    let query;
    let result;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config === null || config === undefined) {
        throw new TypeError('Client was passed a null or undefined query');
    } else if (typeof config.submit === 'function') {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query = config;
        // accept query(new Query(...), (err, res) => { }) style
        if (typeof values === 'function') {
            config.callback = values;
        }
    } else {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        query = new NativeQuery(config, values, callback);
        if (!query.callback) {
            let resolveOut, rejectOut;
            result = new this._Promise((resolve, reject)=>{
                resolveOut = resolve;
                rejectOut = reject;
            }).catch((err)=>{
                Error.captureStackTrace(err);
                throw err;
            });
            query.callback = (err, res)=>err ? rejectOut(err) : resolveOut(res);
        }
    }
    if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(()=>{
            const error = new Error('Query read timeout');
            process.nextTick(()=>{
                query.handleError(error, this.connection);
            });
            queryCallback(error);
            // we already returned an error,
            // just do nothing if query completes
            query.callback = ()=>{};
            // Remove from queue
            const index = this._queryQueue.indexOf(query);
            if (index > -1) {
                this._queryQueue.splice(index, 1);
            }
            this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err, res)=>{
            clearTimeout(readTimeoutTimer);
            queryCallback(err, res);
        };
    }
    if (!this._queryable) {
        query.native = this.native;
        process.nextTick(()=>{
            query.handleError(new Error('Client has encountered a connection error and is not queryable'));
        });
        return result;
    }
    if (this._ending) {
        query.native = this.native;
        process.nextTick(()=>{
            query.handleError(new Error('Client was closed and is not queryable'));
        });
        return result;
    }
    this._queryQueue.push(query);
    this._pulseQueryQueue();
    return result;
};
// disconnect from the backend server
Client.prototype.end = function(cb) {
    const self = this;
    this._ending = true;
    if (!this._connected) {
        this.once('connect', this.end.bind(this, cb));
    }
    let result;
    if (!cb) {
        result = new this._Promise(function(resolve, reject) {
            cb = (err)=>err ? reject(err) : resolve();
        });
    }
    this.native.end(function() {
        self._errorAllQueries(new Error('Connection terminated'));
        process.nextTick(()=>{
            self.emit('end');
            if (cb) cb();
        });
    });
    return result;
};
Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== 'error' && this._activeQuery.state !== 'end';
};
Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
        return;
    }
    if (this._hasActiveQuery()) {
        return;
    }
    const query = this._queryQueue.shift();
    if (!query) {
        if (!initialConnection) {
            this.emit('drain');
        }
        return;
    }
    this._activeQuery = query;
    query.submit(this);
    const self = this;
    query.once('_done', function() {
        self._pulseQueryQueue();
    });
};
// attempt to cancel an in-progress query
Client.prototype.cancel = function(query) {
    if (this._activeQuery === query) {
        this.native.cancel(function() {});
    } else if (this._queryQueue.indexOf(query) !== -1) {
        this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
    }
};
Client.prototype.ref = function() {};
Client.prototype.unref = function() {};
Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
};
Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
};
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/native/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/native/client.js [app-route] (ecmascript)");
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Client = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/client.js [app-route] (ecmascript)");
const defaults = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/defaults.js [app-route] (ecmascript)");
const Connection = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/connection.js [app-route] (ecmascript)");
const Result = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/result.js [app-route] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/utils.js [app-route] (ecmascript)");
const Pool = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-pool@3.11.0_pg@8.18.0/node_modules/pg-pool/index.js [app-route] (ecmascript)");
const TypeOverrides = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/type-overrides.js [app-route] (ecmascript)");
const { DatabaseError } = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/index.js [app-route] (ecmascript)");
const { escapeIdentifier, escapeLiteral } = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/utils.js [app-route] (ecmascript)");
const poolFactory = (Client)=>{
    return class BoundPool extends Pool {
        constructor(options){
            super(options, Client);
        }
    };
};
const PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js [app-route] (ecmascript)");
    this.DatabaseError = DatabaseError;
    this.TypeOverrides = TypeOverrides;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
    this.Result = Result;
    this.utils = utils;
};
let clientConstructor = Client;
let forceNative = false;
try {
    forceNative = !!process.env.NODE_PG_FORCE_NATIVE;
} catch  {
// ignore, e.g., Deno without --allow-env
}
if (forceNative) {
    clientConstructor = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/native/index.js [app-route] (ecmascript)");
}
module.exports = new PG(clientConstructor);
// lazy require native module...the native module may not have installed
Object.defineProperty(module.exports, 'native', {
    configurable: true,
    enumerable: false,
    get () {
        let native = null;
        try {
            native = new PG(__turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/native/index.js [app-route] (ecmascript)"));
        } catch (err) {
            if (err.code !== 'MODULE_NOT_FOUND') {
                throw err;
            }
        }
        // overwrite module.exports.native so that getter is never called again
        Object.defineProperty(module.exports, 'native', {
            value: native
        });
        return native;
    }
});
}),
"[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/esm/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// ESM wrapper for pg
__turbopack_context__.s([
    "Client",
    ()=>Client,
    "Connection",
    ()=>Connection,
    "DatabaseError",
    ()=>DatabaseError,
    "Pool",
    ()=>Pool,
    "Query",
    ()=>Query,
    "Result",
    ()=>Result,
    "TypeOverrides",
    ()=>TypeOverrides,
    "default",
    ()=>__TURBOPACK__default__export__,
    "defaults",
    ()=>defaults,
    "escapeIdentifier",
    ()=>escapeIdentifier,
    "escapeLiteral",
    ()=>escapeLiteral,
    "types",
    ()=>types
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/index.js [app-route] (ecmascript)");
;
const Client = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Client;
const Pool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Pool;
const Connection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Connection;
const types = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].types;
const Query = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Query;
const DatabaseError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DatabaseError;
const escapeIdentifier = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].escapeIdentifier;
const escapeLiteral = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].escapeLiteral;
const Result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Result;
const TypeOverrides = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].TypeOverrides;
const defaults = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].defaults;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
}),
"[project]/node_modules/.pnpm/pg-connection-string@2.11.0/node_modules/pg-connection-string/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

//Parse method copied from https://github.com/brianc/node-postgres
//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)
//MIT License
//parses a connection string
function parse(str, options = {}) {
    //unix socket
    if (str.charAt(0) === '/') {
        const config = str.split(' ');
        return {
            host: config[0],
            database: config[1]
        };
    }
    // Check for empty host in URL
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
        // Ensure spaces are encoded as %20
        str = encodeURI(str).replace(/%25(\d\d)/g, '%$1');
    }
    try {
        try {
            result = new URL(str, 'postgres://base');
        } catch (e) {
            // The URL is invalid so try again with a dummy host
            result = new URL(str.replace('@/', '@___DUMMY___/'), 'postgres://base');
            dummyHost = true;
        }
    } catch (err) {
        // Remove the input from the error message to avoid leaking sensitive information
        err.input && (err.input = '*****REDACTED*****');
        throw err;
    }
    // We'd like to use Object.fromEntries() here but Node.js 10 does not support it
    for (const entry of result.searchParams.entries()){
        config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == 'socket:') {
        config.host = decodeURI(result.pathname);
        config.database = result.searchParams.get('db');
        config.client_encoding = result.searchParams.get('encoding');
        return config;
    }
    const hostname = dummyHost ? '' : result.hostname;
    if (!config.host) {
        // Only set the host if there is no equivalent query param.
        config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
        // Only prepend the hostname to the pathname if it is not a URL encoded Unix socket host.
        result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
        // Only set the port if there is no equivalent query param.
        config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === 'true' || config.ssl === '1') {
        config.ssl = true;
    }
    if (config.ssl === '0') {
        config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
        config.ssl = {};
    }
    // Only try to load fs if we expect to read from the disk
    const fs = config.sslcert || config.sslkey || config.sslrootcert ? __turbopack_context__.r("[externals]/fs [external] (fs, cjs)") : null;
    if (config.sslcert) {
        config.ssl.cert = fs.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
        config.ssl.key = fs.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
        config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config.uselibpqcompat) {
        throw new Error('Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.');
    }
    if (config.uselibpqcompat === 'true' || options.useLibpqCompat) {
        switch(config.sslmode){
            case 'disable':
                {
                    config.ssl = false;
                    break;
                }
            case 'prefer':
                {
                    config.ssl.rejectUnauthorized = false;
                    break;
                }
            case 'require':
                {
                    if (config.sslrootcert) {
                        // If a root CA is specified, behavior of `sslmode=require` will be the same as that of `verify-ca`
                        config.ssl.checkServerIdentity = function() {};
                    } else {
                        config.ssl.rejectUnauthorized = false;
                    }
                    break;
                }
            case 'verify-ca':
                {
                    if (!config.ssl.ca) {
                        throw new Error('SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.');
                    }
                    config.ssl.checkServerIdentity = function() {};
                    break;
                }
            case 'verify-full':
                {
                    break;
                }
        }
    } else {
        switch(config.sslmode){
            case 'disable':
                {
                    config.ssl = false;
                    break;
                }
            case 'prefer':
            case 'require':
            case 'verify-ca':
            case 'verify-full':
                {
                    if (config.sslmode !== 'verify-full') {
                        deprecatedSslModeWarning(config.sslmode);
                    }
                    break;
                }
            case 'no-verify':
                {
                    config.ssl.rejectUnauthorized = false;
                    break;
                }
        }
    }
    return config;
}
// convert pg-connection-string ssl config to a ClientConfig.ConnectionOptions
function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value])=>{
        // we explicitly check for undefined and null instead of `if (value)` because some
        // options accept falsy values. Example: `ssl.rejectUnauthorized = false`
        if (value !== undefined && value !== null) {
            c[key] = value;
        }
        return c;
    }, {});
    return connectionOptions;
}
// convert pg-connection-string config to a ClientConfig
function toClientConfig(config) {
    const poolConfig = Object.entries(config).reduce((c, [key, value])=>{
        if (key === 'ssl') {
            const sslConfig = value;
            if (typeof sslConfig === 'boolean') {
                c[key] = sslConfig;
            }
            if (typeof sslConfig === 'object') {
                c[key] = toConnectionOptions(sslConfig);
            }
        } else if (value !== undefined && value !== null) {
            if (key === 'port') {
                // when port is not specified, it is converted into an empty string
                // we want to avoid NaN or empty string as a values in ClientConfig
                if (value !== '') {
                    const v = parseInt(value, 10);
                    if (isNaN(v)) {
                        throw new Error(`Invalid ${key}: ${value}`);
                    }
                    c[key] = v;
                }
            } else {
                c[key] = value;
            }
        }
        return c;
    }, {});
    return poolConfig;
}
// parses a connection string into ClientConfig
function parseIntoClientConfig(str) {
    return toClientConfig(parse(str));
}
function deprecatedSslModeWarning(sslmode) {
    if (!deprecatedSslModeWarning.warned && typeof process !== 'undefined' && process.emitWarning) {
        deprecatedSslModeWarning.warned = true;
        process.emitWarning(`SECURITY WARNING: The SSL modes 'prefer', 'require', and 'verify-ca' are treated as aliases for 'verify-full'.
In the next major version (pg-connection-string v3.0.0 and pg v9.0.0), these modes will adopt standard libpq semantics, which have weaker security guarantees.

To prepare for this change:
- If you want the current behavior, explicitly use 'sslmode=verify-full'
- If you want libpq compatibility now, use 'uselibpqcompat=true&sslmode=${sslmode}'

See https://www.postgresql.org/docs/current/libpq-ssl.html for libpq SSL mode definitions.`);
    }
}
module.exports = parse;
parse.parse = parse;
parse.toClientConfig = toClientConfig;
parse.parseIntoClientConfig = parseIntoClientConfig;
}),
"[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/messages.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = void 0;
exports.parseComplete = {
    name: 'parseComplete',
    length: 5
};
exports.bindComplete = {
    name: 'bindComplete',
    length: 5
};
exports.closeComplete = {
    name: 'closeComplete',
    length: 5
};
exports.noData = {
    name: 'noData',
    length: 5
};
exports.portalSuspended = {
    name: 'portalSuspended',
    length: 5
};
exports.replicationStart = {
    name: 'replicationStart',
    length: 4
};
exports.emptyQuery = {
    name: 'emptyQuery',
    length: 4
};
exports.copyDone = {
    name: 'copyDone',
    length: 4
};
class DatabaseError extends Error {
    constructor(message, length, name){
        super(message);
        this.length = length;
        this.name = name;
    }
}
exports.DatabaseError = DatabaseError;
class CopyDataMessage {
    constructor(length, chunk){
        this.length = length;
        this.chunk = chunk;
        this.name = 'copyData';
    }
}
exports.CopyDataMessage = CopyDataMessage;
class CopyResponse {
    constructor(length, name, binary, columnCount){
        this.length = length;
        this.name = name;
        this.binary = binary;
        this.columnTypes = new Array(columnCount);
    }
}
exports.CopyResponse = CopyResponse;
class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format){
        this.name = name;
        this.tableID = tableID;
        this.columnID = columnID;
        this.dataTypeID = dataTypeID;
        this.dataTypeSize = dataTypeSize;
        this.dataTypeModifier = dataTypeModifier;
        this.format = format;
    }
}
exports.Field = Field;
class RowDescriptionMessage {
    constructor(length, fieldCount){
        this.length = length;
        this.fieldCount = fieldCount;
        this.name = 'rowDescription';
        this.fields = new Array(this.fieldCount);
    }
}
exports.RowDescriptionMessage = RowDescriptionMessage;
class ParameterDescriptionMessage {
    constructor(length, parameterCount){
        this.length = length;
        this.parameterCount = parameterCount;
        this.name = 'parameterDescription';
        this.dataTypeIDs = new Array(this.parameterCount);
    }
}
exports.ParameterDescriptionMessage = ParameterDescriptionMessage;
class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue){
        this.length = length;
        this.parameterName = parameterName;
        this.parameterValue = parameterValue;
        this.name = 'parameterStatus';
    }
}
exports.ParameterStatusMessage = ParameterStatusMessage;
class AuthenticationMD5Password {
    constructor(length, salt){
        this.length = length;
        this.salt = salt;
        this.name = 'authenticationMD5Password';
    }
}
exports.AuthenticationMD5Password = AuthenticationMD5Password;
class BackendKeyDataMessage {
    constructor(length, processID, secretKey){
        this.length = length;
        this.processID = processID;
        this.secretKey = secretKey;
        this.name = 'backendKeyData';
    }
}
exports.BackendKeyDataMessage = BackendKeyDataMessage;
class NotificationResponseMessage {
    constructor(length, processId, channel, payload){
        this.length = length;
        this.processId = processId;
        this.channel = channel;
        this.payload = payload;
        this.name = 'notification';
    }
}
exports.NotificationResponseMessage = NotificationResponseMessage;
class ReadyForQueryMessage {
    constructor(length, status){
        this.length = length;
        this.status = status;
        this.name = 'readyForQuery';
    }
}
exports.ReadyForQueryMessage = ReadyForQueryMessage;
class CommandCompleteMessage {
    constructor(length, text){
        this.length = length;
        this.text = text;
        this.name = 'commandComplete';
    }
}
exports.CommandCompleteMessage = CommandCompleteMessage;
class DataRowMessage {
    constructor(length, fields){
        this.length = length;
        this.fields = fields;
        this.name = 'dataRow';
        this.fieldCount = fields.length;
    }
}
exports.DataRowMessage = DataRowMessage;
class NoticeMessage {
    constructor(length, message){
        this.length = length;
        this.message = message;
        this.name = 'notice';
    }
}
exports.NoticeMessage = NoticeMessage; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/buffer-writer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

//binary data writer tuned for encoding binary specific to the postgres binary protocol
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Writer = void 0;
class Writer {
    constructor(size = 256){
        this.size = size;
        this.offset = 5;
        this.headerPosition = 0;
        this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
        const remaining = this.buffer.length - this.offset;
        if (remaining < size) {
            const oldBuffer = this.buffer;
            // exponential growth factor of around ~ 1.5
            // https://stackoverflow.com/questions/2269063/buffer-growth-strategy
            const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
            this.buffer = Buffer.allocUnsafe(newSize);
            oldBuffer.copy(this.buffer);
        }
    }
    addInt32(num) {
        this.ensure(4);
        this.buffer[this.offset++] = num >>> 24 & 0xff;
        this.buffer[this.offset++] = num >>> 16 & 0xff;
        this.buffer[this.offset++] = num >>> 8 & 0xff;
        this.buffer[this.offset++] = num >>> 0 & 0xff;
        return this;
    }
    addInt16(num) {
        this.ensure(2);
        this.buffer[this.offset++] = num >>> 8 & 0xff;
        this.buffer[this.offset++] = num >>> 0 & 0xff;
        return this;
    }
    addCString(string) {
        if (!string) {
            this.ensure(1);
        } else {
            const len = Buffer.byteLength(string);
            this.ensure(len + 1); // +1 for null terminator
            this.buffer.write(string, this.offset, 'utf-8');
            this.offset += len;
        }
        this.buffer[this.offset++] = 0; // null terminator
        return this;
    }
    addString(string = '') {
        const len = Buffer.byteLength(string);
        this.ensure(len);
        this.buffer.write(string, this.offset);
        this.offset += len;
        return this;
    }
    add(otherBuffer) {
        this.ensure(otherBuffer.length);
        otherBuffer.copy(this.buffer, this.offset);
        this.offset += otherBuffer.length;
        return this;
    }
    join(code) {
        if (code) {
            this.buffer[this.headerPosition] = code;
            //length is everything in this packet minus the code
            const length = this.offset - (this.headerPosition + 1);
            this.buffer.writeInt32BE(length, this.headerPosition + 1);
        }
        return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
        const result = this.join(code);
        this.offset = 5;
        this.headerPosition = 0;
        this.buffer = Buffer.allocUnsafe(this.size);
        return result;
    }
}
exports.Writer = Writer; //# sourceMappingURL=buffer-writer.js.map
}),
"[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/serializer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serialize = void 0;
const buffer_writer_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/buffer-writer.js [app-route] (ecmascript)");
const writer = new buffer_writer_1.Writer();
const startup = (opts)=>{
    // protocol version
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)){
        writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString('client_encoding').addCString('UTF8');
    const bodyBuffer = writer.addCString('').flush();
    // this message is sent without a code
    const length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
};
const requestSsl = ()=>{
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
};
const password = (password)=>{
    return writer.addCString(password).flush(112 /* code.startup */ );
};
const sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    // 0x70 = 'p'
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112 /* code.startup */ );
};
const sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112 /* code.startup */ );
};
const query = (text)=>{
    return writer.addCString(text).flush(81 /* code.query */ );
};
const emptyArray = [];
const parse = (query)=>{
    // expect something like this:
    // { name: 'queryName',
    //   text: 'select * from blah',
    //   types: ['int8', 'bool'] }
    // normalize missing query names to allow for null
    const name = query.name || '';
    if (name.length > 63) {
        console.error('Warning! Postgres only supports 63 characters for query names.');
        console.error('You supplied %s (%s)', name, name.length);
        console.error('This can cause conflicts and silent errors executing queries');
    }
    const types = query.types || emptyArray;
    const len = types.length;
    const buffer = writer.addCString(name) // name of query
    .addCString(query.text) // actual query text
    .addInt16(len);
    for(let i = 0; i < len; i++){
        buffer.addInt32(types[i]);
    }
    return writer.flush(80 /* code.parse */ );
};
const paramWriter = new buffer_writer_1.Writer();
const writeValues = function(values, valueMapper) {
    for(let i = 0; i < values.length; i++){
        const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
        if (mappedVal == null) {
            // add the param type (string) to the writer
            writer.addInt16(0 /* ParamType.STRING */ );
            // write -1 to the param writer to indicate null
            paramWriter.addInt32(-1);
        } else if (mappedVal instanceof Buffer) {
            // add the param type (binary) to the writer
            writer.addInt16(1 /* ParamType.BINARY */ );
            // add the buffer to the param writer
            paramWriter.addInt32(mappedVal.length);
            paramWriter.add(mappedVal);
        } else {
            // add the param type (string) to the writer
            writer.addInt16(0 /* ParamType.STRING */ );
            paramWriter.addInt32(Buffer.byteLength(mappedVal));
            paramWriter.addString(mappedVal);
        }
    }
};
const bind = (config = {})=>{
    // normalize config
    const portal = config.portal || '';
    const statement = config.statement || '';
    const binary = config.binary || false;
    const values = config.values || emptyArray;
    const len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    // all results use the same format code
    writer.addInt16(1);
    // format code
    writer.addInt16(binary ? 1 /* ParamType.BINARY */  : 0 /* ParamType.STRING */ );
    return writer.flush(66 /* code.bind */ );
};
const emptyExecute = Buffer.from([
    69 /* code.execute */ ,
    0x00,
    0x00,
    0x00,
    0x09,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00
]);
const execute = (config)=>{
    // this is the happy path for most queries
    if (!config || !config.portal && !config.rows) {
        return emptyExecute;
    }
    const portal = config.portal || '';
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    // one extra bit for code
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69 /* code.execute */ ;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, 'utf-8');
    buff[portalLength + 5] = 0; // null terminate portal cString
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
};
const cancel = (processID, secretKey)=>{
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
};
const cstringMessage = (code, string)=>{
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    // one extra bit for code
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, 'utf-8');
    buffer[len] = 0; // null terminate cString
    return buffer;
};
const emptyDescribePortal = writer.addCString('P').flush(68 /* code.describe */ );
const emptyDescribeStatement = writer.addCString('S').flush(68 /* code.describe */ );
const describe = (msg)=>{
    return msg.name ? cstringMessage(68 /* code.describe */ , `${msg.type}${msg.name || ''}`) : msg.type === 'P' ? emptyDescribePortal : emptyDescribeStatement;
};
const close = (msg)=>{
    const text = `${msg.type}${msg.name || ''}`;
    return cstringMessage(67 /* code.close */ , text);
};
const copyData = (chunk)=>{
    return writer.add(chunk).flush(100 /* code.copyFromChunk */ );
};
const copyFail = (message)=>{
    return cstringMessage(102 /* code.copyFail */ , message);
};
const codeOnlyBuffer = (code)=>Buffer.from([
        code,
        0x00,
        0x00,
        0x00,
        0x04
    ]);
const flushBuffer = codeOnlyBuffer(72 /* code.flush */ );
const syncBuffer = codeOnlyBuffer(83 /* code.sync */ );
const endBuffer = codeOnlyBuffer(88 /* code.end */ );
const copyDoneBuffer = codeOnlyBuffer(99 /* code.copyDone */ );
const serialize = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query,
    parse,
    bind,
    execute,
    describe,
    close,
    flush: ()=>flushBuffer,
    sync: ()=>syncBuffer,
    end: ()=>endBuffer,
    copyData,
    copyDone: ()=>copyDoneBuffer,
    copyFail,
    cancel
};
exports.serialize = serialize; //# sourceMappingURL=serializer.js.map
}),
"[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/buffer-reader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BufferReader = void 0;
const emptyBuffer = Buffer.allocUnsafe(0);
class BufferReader {
    constructor(offset = 0){
        this.offset = offset;
        this.buffer = emptyBuffer;
        // TODO(bmc): support non-utf8 encoding?
        this.encoding = 'utf-8';
    }
    setBuffer(offset, buffer) {
        this.offset = offset;
        this.buffer = buffer;
    }
    int16() {
        const result = this.buffer.readInt16BE(this.offset);
        this.offset += 2;
        return result;
    }
    byte() {
        const result = this.buffer[this.offset];
        this.offset++;
        return result;
    }
    int32() {
        const result = this.buffer.readInt32BE(this.offset);
        this.offset += 4;
        return result;
    }
    uint32() {
        const result = this.buffer.readUInt32BE(this.offset);
        this.offset += 4;
        return result;
    }
    string(length) {
        const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
        this.offset += length;
        return result;
    }
    cstring() {
        const start = this.offset;
        let end = start;
        // eslint-disable-next-line no-empty
        while(this.buffer[end++] !== 0){}
        this.offset = end;
        return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
        const result = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return result;
    }
}
exports.BufferReader = BufferReader; //# sourceMappingURL=buffer-reader.js.map
}),
"[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Parser = void 0;
const messages_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/messages.js [app-route] (ecmascript)");
const buffer_reader_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/buffer-reader.js [app-route] (ecmascript)");
// every message is prefixed with a single bye
const CODE_LENGTH = 1;
// every message has an int32 length which includes itself but does
// NOT include the code in the length
const LEN_LENGTH = 4;
const HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
// A placeholder for a `BackendMessage`s length value that will be set after construction.
const LATEINIT_LENGTH = -1;
const emptyBuffer = Buffer.allocUnsafe(0);
class Parser {
    constructor(opts){
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
        this.reader = new buffer_reader_1.BufferReader();
        if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {
            throw new Error('Binary mode not supported yet');
        }
        this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';
    }
    parse(buffer, callback) {
        this.mergeBuffer(buffer);
        const bufferFullLength = this.bufferOffset + this.bufferLength;
        let offset = this.bufferOffset;
        while(offset + HEADER_LENGTH <= bufferFullLength){
            // code is 1 byte long - it identifies the message type
            const code = this.buffer[offset];
            // length is 1 Uint32BE - it is the length of the message EXCLUDING the code
            const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
            const fullMessageLength = CODE_LENGTH + length;
            if (fullMessageLength + offset <= bufferFullLength) {
                const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
                callback(message);
                offset += fullMessageLength;
            } else {
                break;
            }
        }
        if (offset === bufferFullLength) {
            // No more use for the buffer
            this.buffer = emptyBuffer;
            this.bufferLength = 0;
            this.bufferOffset = 0;
        } else {
            // Adjust the cursors of remainingBuffer
            this.bufferLength = bufferFullLength - offset;
            this.bufferOffset = offset;
        }
    }
    mergeBuffer(buffer) {
        if (this.bufferLength > 0) {
            const newLength = this.bufferLength + buffer.byteLength;
            const newFullLength = newLength + this.bufferOffset;
            if (newFullLength > this.buffer.byteLength) {
                // We can't concat the new buffer with the remaining one
                let newBuffer;
                if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
                    // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer
                    newBuffer = this.buffer;
                } else {
                    // Allocate a new larger buffer
                    let newBufferLength = this.buffer.byteLength * 2;
                    while(newLength >= newBufferLength){
                        newBufferLength *= 2;
                    }
                    newBuffer = Buffer.allocUnsafe(newBufferLength);
                }
                // Move the remaining buffer to the new one
                this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
                this.buffer = newBuffer;
                this.bufferOffset = 0;
            }
            // Concat the new buffer with the remaining one
            buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
            this.bufferLength = newLength;
        } else {
            this.buffer = buffer;
            this.bufferOffset = 0;
            this.bufferLength = buffer.byteLength;
        }
    }
    handlePacket(offset, code, length, bytes) {
        const { reader } = this;
        // NOTE: This undesirably retains the buffer in `this.reader` if the `parse*Message` calls below throw. However, those should only throw in the case of a protocol error, which normally results in the reader being discarded.
        reader.setBuffer(offset, bytes);
        let message;
        switch(code){
            case 50 /* MessageCodes.BindComplete */ :
                message = messages_1.bindComplete;
                break;
            case 49 /* MessageCodes.ParseComplete */ :
                message = messages_1.parseComplete;
                break;
            case 51 /* MessageCodes.CloseComplete */ :
                message = messages_1.closeComplete;
                break;
            case 110 /* MessageCodes.NoData */ :
                message = messages_1.noData;
                break;
            case 115 /* MessageCodes.PortalSuspended */ :
                message = messages_1.portalSuspended;
                break;
            case 99 /* MessageCodes.CopyDone */ :
                message = messages_1.copyDone;
                break;
            case 87 /* MessageCodes.ReplicationStart */ :
                message = messages_1.replicationStart;
                break;
            case 73 /* MessageCodes.EmptyQuery */ :
                message = messages_1.emptyQuery;
                break;
            case 68 /* MessageCodes.DataRow */ :
                message = parseDataRowMessage(reader);
                break;
            case 67 /* MessageCodes.CommandComplete */ :
                message = parseCommandCompleteMessage(reader);
                break;
            case 90 /* MessageCodes.ReadyForQuery */ :
                message = parseReadyForQueryMessage(reader);
                break;
            case 65 /* MessageCodes.NotificationResponse */ :
                message = parseNotificationMessage(reader);
                break;
            case 82 /* MessageCodes.AuthenticationResponse */ :
                message = parseAuthenticationResponse(reader, length);
                break;
            case 83 /* MessageCodes.ParameterStatus */ :
                message = parseParameterStatusMessage(reader);
                break;
            case 75 /* MessageCodes.BackendKeyData */ :
                message = parseBackendKeyData(reader);
                break;
            case 69 /* MessageCodes.ErrorMessage */ :
                message = parseErrorMessage(reader, 'error');
                break;
            case 78 /* MessageCodes.NoticeMessage */ :
                message = parseErrorMessage(reader, 'notice');
                break;
            case 84 /* MessageCodes.RowDescriptionMessage */ :
                message = parseRowDescriptionMessage(reader);
                break;
            case 116 /* MessageCodes.ParameterDescriptionMessage */ :
                message = parseParameterDescriptionMessage(reader);
                break;
            case 71 /* MessageCodes.CopyIn */ :
                message = parseCopyInMessage(reader);
                break;
            case 72 /* MessageCodes.CopyOut */ :
                message = parseCopyOutMessage(reader);
                break;
            case 100 /* MessageCodes.CopyData */ :
                message = parseCopyData(reader, length);
                break;
            default:
                return new messages_1.DatabaseError('received invalid response: ' + code.toString(16), length, 'error');
        }
        reader.setBuffer(0, emptyBuffer);
        message.length = length;
        return message;
    }
}
exports.Parser = Parser;
const parseReadyForQueryMessage = (reader)=>{
    const status = reader.string(1);
    return new messages_1.ReadyForQueryMessage(LATEINIT_LENGTH, status);
};
const parseCommandCompleteMessage = (reader)=>{
    const text = reader.cstring();
    return new messages_1.CommandCompleteMessage(LATEINIT_LENGTH, text);
};
const parseCopyData = (reader, length)=>{
    const chunk = reader.bytes(length - 4);
    return new messages_1.CopyDataMessage(LATEINIT_LENGTH, chunk);
};
const parseCopyInMessage = (reader)=>parseCopyMessage(reader, 'copyInResponse');
const parseCopyOutMessage = (reader)=>parseCopyMessage(reader, 'copyOutResponse');
const parseCopyMessage = (reader, messageName)=>{
    const isBinary = reader.byte() !== 0;
    const columnCount = reader.int16();
    const message = new messages_1.CopyResponse(LATEINIT_LENGTH, messageName, isBinary, columnCount);
    for(let i = 0; i < columnCount; i++){
        message.columnTypes[i] = reader.int16();
    }
    return message;
};
const parseNotificationMessage = (reader)=>{
    const processId = reader.int32();
    const channel = reader.cstring();
    const payload = reader.cstring();
    return new messages_1.NotificationResponseMessage(LATEINIT_LENGTH, processId, channel, payload);
};
const parseRowDescriptionMessage = (reader)=>{
    const fieldCount = reader.int16();
    const message = new messages_1.RowDescriptionMessage(LATEINIT_LENGTH, fieldCount);
    for(let i = 0; i < fieldCount; i++){
        message.fields[i] = parseField(reader);
    }
    return message;
};
const parseField = (reader)=>{
    const name = reader.cstring();
    const tableID = reader.uint32();
    const columnID = reader.int16();
    const dataTypeID = reader.uint32();
    const dataTypeSize = reader.int16();
    const dataTypeModifier = reader.int32();
    const mode = reader.int16() === 0 ? 'text' : 'binary';
    return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
};
const parseParameterDescriptionMessage = (reader)=>{
    const parameterCount = reader.int16();
    const message = new messages_1.ParameterDescriptionMessage(LATEINIT_LENGTH, parameterCount);
    for(let i = 0; i < parameterCount; i++){
        message.dataTypeIDs[i] = reader.int32();
    }
    return message;
};
const parseDataRowMessage = (reader)=>{
    const fieldCount = reader.int16();
    const fields = new Array(fieldCount);
    for(let i = 0; i < fieldCount; i++){
        const len = reader.int32();
        // a -1 for length means the value of the field is null
        fields[i] = len === -1 ? null : reader.string(len);
    }
    return new messages_1.DataRowMessage(LATEINIT_LENGTH, fields);
};
const parseParameterStatusMessage = (reader)=>{
    const name = reader.cstring();
    const value = reader.cstring();
    return new messages_1.ParameterStatusMessage(LATEINIT_LENGTH, name, value);
};
const parseBackendKeyData = (reader)=>{
    const processID = reader.int32();
    const secretKey = reader.int32();
    return new messages_1.BackendKeyDataMessage(LATEINIT_LENGTH, processID, secretKey);
};
const parseAuthenticationResponse = (reader, length)=>{
    const code = reader.int32();
    // TODO(bmc): maybe better types here
    const message = {
        name: 'authenticationOk',
        length
    };
    switch(code){
        case 0:
            break;
        case 3:
            if (message.length === 8) {
                message.name = 'authenticationCleartextPassword';
            }
            break;
        case 5:
            if (message.length === 12) {
                message.name = 'authenticationMD5Password';
                const salt = reader.bytes(4);
                return new messages_1.AuthenticationMD5Password(LATEINIT_LENGTH, salt);
            }
            break;
        case 10:
            {
                message.name = 'authenticationSASL';
                message.mechanisms = [];
                let mechanism;
                do {
                    mechanism = reader.cstring();
                    if (mechanism) {
                        message.mechanisms.push(mechanism);
                    }
                }while (mechanism)
            }
            break;
        case 11:
            message.name = 'authenticationSASLContinue';
            message.data = reader.string(length - 8);
            break;
        case 12:
            message.name = 'authenticationSASLFinal';
            message.data = reader.string(length - 8);
            break;
        default:
            throw new Error('Unknown authenticationOk message type ' + code);
    }
    return message;
};
const parseErrorMessage = (reader, name)=>{
    const fields = {};
    let fieldType = reader.string(1);
    while(fieldType !== '\0'){
        fields[fieldType] = reader.cstring();
        fieldType = reader.string(1);
    }
    const messageValue = fields.M;
    const message = name === 'notice' ? new messages_1.NoticeMessage(LATEINIT_LENGTH, messageValue) : new messages_1.DatabaseError(messageValue, LATEINIT_LENGTH, name);
    message.severity = fields.S;
    message.code = fields.C;
    message.detail = fields.D;
    message.hint = fields.H;
    message.position = fields.P;
    message.internalPosition = fields.p;
    message.internalQuery = fields.q;
    message.where = fields.W;
    message.schema = fields.s;
    message.table = fields.t;
    message.column = fields.c;
    message.dataType = fields.d;
    message.constraint = fields.n;
    message.file = fields.F;
    message.line = fields.L;
    message.routine = fields.R;
    return message;
}; //# sourceMappingURL=parser.js.map
}),
"[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DatabaseError = exports.serialize = exports.parse = void 0;
const messages_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/messages.js [app-route] (ecmascript)");
Object.defineProperty(exports, "DatabaseError", {
    enumerable: true,
    get: function() {
        return messages_1.DatabaseError;
    }
});
const serializer_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/serializer.js [app-route] (ecmascript)");
Object.defineProperty(exports, "serialize", {
    enumerable: true,
    get: function() {
        return serializer_1.serialize;
    }
});
const parser_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-protocol@1.11.0/node_modules/pg-protocol/dist/parser.js [app-route] (ecmascript)");
function parse(stream, callback) {
    const parser = new parser_1.Parser();
    stream.on('data', (buffer)=>parser.parse(buffer, callback));
    return new Promise((resolve)=>stream.on('end', ()=>resolve()));
}
exports.parse = parse; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/pg-cloudflare@1.3.0/node_modules/pg-cloudflare/dist/empty.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
// This is an empty module that is served up when outside of a workerd environment
// See the `exports` field in package.json
exports.default = {}; //# sourceMappingURL=empty.js.map
}),
"[project]/node_modules/.pnpm/split2@4.2.0/node_modules/split2/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
Copyright (c) 2014-2021, Matteo Collina <hello@matteocollina.com>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/ const { Transform } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const { StringDecoder } = __turbopack_context__.r("[externals]/string_decoder [external] (string_decoder, cjs)");
const kLast = Symbol('last');
const kDecoder = Symbol('decoder');
function transform(chunk, enc, cb) {
    let list;
    if (this.overflow) {
        const buf = this[kDecoder].write(chunk);
        list = buf.split(this.matcher);
        if (list.length === 1) return cb() // Line ending not found. Discard entire chunk.
        ;
        // Line ending found. Discard trailing fragment of previous line and reset overflow state.
        list.shift();
        this.overflow = false;
    } else {
        this[kLast] += this[kDecoder].write(chunk);
        list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for(let i = 0; i < list.length; i++){
        try {
            push(this, this.mapper(list[i]));
        } catch (error) {
            return cb(error);
        }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
        cb(new Error('maximum buffer reached'));
        return;
    }
    cb();
}
function flush(cb) {
    // forward any gibberish left in there
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
        try {
            push(this, this.mapper(this[kLast]));
        } catch (error) {
            return cb(error);
        }
    }
    cb();
}
function push(self, val) {
    if (val !== undefined) {
        self.push(val);
    }
}
function noop(incoming) {
    return incoming;
}
function split(matcher, mapper, options) {
    // Set defaults for any arguments not supplied.
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop;
    options = options || {};
    // Test arguments explicitly.
    switch(arguments.length){
        case 1:
            // If mapper is only argument.
            if (typeof matcher === 'function') {
                mapper = matcher;
                matcher = /\r?\n/;
            // If options is only argument.
            } else if (typeof matcher === 'object' && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
                options = matcher;
                matcher = /\r?\n/;
            }
            break;
        case 2:
            // If mapper and options are arguments.
            if (typeof matcher === 'function') {
                options = mapper;
                mapper = matcher;
                matcher = /\r?\n/;
            // If matcher and options are arguments.
            } else if (typeof mapper === 'object') {
                options = mapper;
                mapper = noop;
            }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform(options);
    stream[kLast] = '';
    stream[kDecoder] = new StringDecoder('utf8');
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
        // Weird Node v12 bug that we need to work around
        this._writableState.errorEmitted = false;
        cb(err);
    };
    return stream;
}
module.exports = split;
}),
"[project]/node_modules/.pnpm/pgpass@1.0.5/node_modules/pgpass/lib/helper.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)"), Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream, split = __turbopack_context__.r("[project]/node_modules/.pnpm/split2@4.2.0/node_modules/split2/index.js [app-route] (ecmascript)"), util = __turbopack_context__.r("[externals]/util [external] (util, cjs)"), defaultPort = 5432, isWin = process.platform === 'win32', warnStream = process.stderr;
var S_IRWXG = 56 //    00070(8)
, S_IRWXO = 7 //    00007(8)
, S_IFMT = 61440 // 00170000(8)
, S_IFREG = 32768 //  0100000(8)
;
function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
}
var fieldNames = [
    'host',
    'port',
    'database',
    'user',
    'password'
];
var nrOfFields = fieldNames.length;
var passKey = fieldNames[nrOfFields - 1];
function warn() {
    var isWritable = warnStream instanceof Stream && true === warnStream.writable;
    if (isWritable) {
        var args = Array.prototype.slice.call(arguments).concat("\n");
        warnStream.write(util.format.apply(util, args));
    }
}
Object.defineProperty(module.exports, 'isWin', {
    get: function() {
        return isWin;
    },
    set: function(val) {
        isWin = val;
    }
});
module.exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
};
module.exports.getFileName = function(rawEnv) {
    var env = rawEnv || process.env;
    var file = env.PGPASSFILE || (isWin ? path.join(env.APPDATA || './', 'postgresql', 'pgpass.conf') : path.join(env.HOME || './', '.pgpass'));
    return file;
};
module.exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, 'PGPASSWORD')) {
        return false;
    }
    if (isWin) {
        return true;
    }
    fname = fname || '<unkn>';
    if (!isRegFile(stats.mode)) {
        warn('WARNING: password file "%s" is not a plain file', fname);
        return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
        /* If password file is insecure, alert the user and ignore it. */ warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
        return false;
    }
    return true;
};
var matcher = module.exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
        if (idx == 1) {
            // the port
            if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
                return prev && true;
            }
        }
        return prev && (entry[field] === '*' || entry[field] === connInfo[field]);
    }, true);
};
module.exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line) {
        var entry = parseLine(line);
        if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
            pass = entry[passKey];
            lineStream.end(); // -> calls onEnd(), but pass is set now
        }
    }
    var onEnd = function() {
        stream.destroy();
        cb(pass);
    };
    var onErr = function(err) {
        stream.destroy();
        warn('WARNING: error on reading file: %s', err);
        cb(undefined);
    };
    stream.on('error', onErr);
    lineStream.on('data', onLine).on('end', onEnd).on('error', onErr);
};
var parseLine = module.exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
        return null;
    }
    var curChar = '';
    var prevChar = '';
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
        var field = line.substring(i0, i1);
        if (!Object.hasOwnProperty.call(process.env, 'PGPASS_NO_DEESCAPE')) {
            field = field.replace(/\\([:\\])/g, '$1');
        }
        obj[fieldNames[idx]] = field;
    };
    for(var i = 0; i < line.length - 1; i += 1){
        curChar = line.charAt(i + 1);
        prevChar = line.charAt(i);
        isLastField = fieldIdx == nrOfFields - 1;
        if (isLastField) {
            addToObj(fieldIdx, startIdx);
            break;
        }
        if (i >= 0 && curChar == ':' && prevChar !== '\\') {
            addToObj(fieldIdx, startIdx, i + 1);
            startIdx = i + 2;
            fieldIdx += 1;
        }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
};
var isValidEntry = module.exports.isValidEntry = function(entry) {
    var rules = {
        // host
        0: function(x) {
            return x.length > 0;
        },
        // port
        1: function(x) {
            if (x === '*') {
                return true;
            }
            x = Number(x);
            return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
        },
        // database
        2: function(x) {
            return x.length > 0;
        },
        // username
        3: function(x) {
            return x.length > 0;
        },
        // password
        4: function(x) {
            return x.length > 0;
        }
    };
    for(var idx = 0; idx < fieldNames.length; idx += 1){
        var rule = rules[idx];
        var value = entry[fieldNames[idx]] || '';
        var res = rule(value);
        if (!res) {
            return false;
        }
    }
    return true;
};
}),
"[project]/node_modules/.pnpm/pgpass@1.0.5/node_modules/pgpass/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)"), fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)"), helper = __turbopack_context__.r("[project]/node_modules/.pnpm/pgpass@1.0.5/node_modules/pgpass/lib/helper.js [app-route] (ecmascript)");
module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs.stat(file, function(err, stat) {
        if (err || !helper.usePgPass(stat, file)) {
            return cb(undefined);
        }
        var st = fs.createReadStream(file);
        helper.getPassword(connInfo, st, cb);
    });
};
module.exports.warnTo = helper.warnTo;
}),
"[project]/node_modules/.pnpm/pg-pool@3.11.0_pg@8.18.0/node_modules/pg-pool/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)").EventEmitter;
const NOOP = function() {};
const removeWhere = (list, predicate)=>{
    const i = list.findIndex(predicate);
    return i === -1 ? undefined : list.splice(i, 1)[0];
};
class IdleItem {
    constructor(client, idleListener, timeoutId){
        this.client = client;
        this.idleListener = idleListener;
        this.timeoutId = timeoutId;
    }
}
class PendingItem {
    constructor(callback){
        this.callback = callback;
    }
}
function throwOnDoubleRelease() {
    throw new Error('Release called on client which has already been released to the pool.');
}
function promisify(Promise, callback) {
    if (callback) {
        return {
            callback: callback,
            result: undefined
        };
    }
    let rej;
    let res;
    const cb = function(err, client) {
        err ? rej(err) : res(client);
    };
    const result = new Promise(function(resolve, reject) {
        res = resolve;
        rej = reject;
    }).catch((err)=>{
        // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the
        // application that created the query
        Error.captureStackTrace(err);
        throw err;
    });
    return {
        callback: cb,
        result: result
    };
}
function makeIdleListener(pool, client) {
    return function idleListener(err) {
        err.client = client;
        client.removeListener('error', idleListener);
        client.on('error', ()=>{
            pool.log('additional client error after disconnection due to error', err);
        });
        pool._remove(client);
        // TODO - document that once the pool emits an error
        // the client has already been closed & purged and is unusable
        pool.emit('error', err, client);
    };
}
class Pool extends EventEmitter {
    constructor(options, Client){
        super();
        this.options = Object.assign({}, options);
        if (options != null && 'password' in options) {
            // "hiding" the password so it doesn't show up in stack traces
            // or if the client is console.logged
            Object.defineProperty(this.options, 'password', {
                configurable: true,
                enumerable: false,
                writable: true,
                value: options.password
            });
        }
        if (options != null && options.ssl && options.ssl.key) {
            // "hiding" the ssl->key so it doesn't show up in stack traces
            // or if the client is console.logged
            Object.defineProperty(this.options.ssl, 'key', {
                enumerable: false
            });
        }
        this.options.max = this.options.max || this.options.poolSize || 10;
        this.options.min = this.options.min || 0;
        this.options.maxUses = this.options.maxUses || Infinity;
        this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
        this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
        this.log = this.options.log || function() {};
        this.Client = this.options.Client || Client || __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/index.js [app-route] (ecmascript)").Client;
        this.Promise = this.options.Promise || /*TURBOPACK member replacement*/ __turbopack_context__.g.Promise;
        if (typeof this.options.idleTimeoutMillis === 'undefined') {
            this.options.idleTimeoutMillis = 10000;
        }
        this._clients = [];
        this._idle = [];
        this._expired = new WeakSet();
        this._pendingQueue = [];
        this._endCallback = undefined;
        this.ending = false;
        this.ended = false;
    }
    _isFull() {
        return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
        return this._clients.length > this.options.min;
    }
    _pulseQueue() {
        this.log('pulse queue');
        if (this.ended) {
            this.log('pulse queue ended');
            return;
        }
        if (this.ending) {
            this.log('pulse queue on ending');
            if (this._idle.length) {
                this._idle.slice().map((item)=>{
                    this._remove(item.client);
                });
            }
            if (!this._clients.length) {
                this.ended = true;
                this._endCallback();
            }
            return;
        }
        // if we don't have any waiting, do nothing
        if (!this._pendingQueue.length) {
            this.log('no queued requests');
            return;
        }
        // if we don't have any idle clients and we have no more room do nothing
        if (!this._idle.length && this._isFull()) {
            return;
        }
        const pendingItem = this._pendingQueue.shift();
        if (this._idle.length) {
            const idleItem = this._idle.pop();
            clearTimeout(idleItem.timeoutId);
            const client = idleItem.client;
            client.ref && client.ref();
            const idleListener = idleItem.idleListener;
            return this._acquireClient(client, pendingItem, idleListener, false);
        }
        if (!this._isFull()) {
            return this.newClient(pendingItem);
        }
        throw new Error('unexpected condition');
    }
    _remove(client, callback) {
        const removed = removeWhere(this._idle, (item)=>item.client === client);
        if (removed !== undefined) {
            clearTimeout(removed.timeoutId);
        }
        this._clients = this._clients.filter((c)=>c !== client);
        const context = this;
        client.end(()=>{
            context.emit('remove', client);
            if (typeof callback === 'function') {
                callback();
            }
        });
    }
    connect(cb) {
        if (this.ending) {
            const err = new Error('Cannot use a pool after calling end on the pool');
            return cb ? cb(err) : this.Promise.reject(err);
        }
        const response = promisify(this.Promise, cb);
        const result = response.result;
        // if we don't have to connect a new client, don't do so
        if (this._isFull() || this._idle.length) {
            // if we have idle clients schedule a pulse immediately
            if (this._idle.length) {
                process.nextTick(()=>this._pulseQueue());
            }
            if (!this.options.connectionTimeoutMillis) {
                this._pendingQueue.push(new PendingItem(response.callback));
                return result;
            }
            const queueCallback = (err, res, done)=>{
                clearTimeout(tid);
                response.callback(err, res, done);
            };
            const pendingItem = new PendingItem(queueCallback);
            // set connection timeout on checking out an existing client
            const tid = setTimeout(()=>{
                // remove the callback from pending waiters because
                // we're going to call it with a timeout error
                removeWhere(this._pendingQueue, (i)=>i.callback === queueCallback);
                pendingItem.timedOut = true;
                response.callback(new Error('timeout exceeded when trying to connect'));
            }, this.options.connectionTimeoutMillis);
            if (tid.unref) {
                tid.unref();
            }
            this._pendingQueue.push(pendingItem);
            return result;
        }
        this.newClient(new PendingItem(response.callback));
        return result;
    }
    newClient(pendingItem) {
        const client = new this.Client(this.options);
        this._clients.push(client);
        const idleListener = makeIdleListener(this, client);
        this.log('checking client timeout');
        // connection timeout logic
        let tid;
        let timeoutHit = false;
        if (this.options.connectionTimeoutMillis) {
            tid = setTimeout(()=>{
                this.log('ending client due to timeout');
                timeoutHit = true;
                // force kill the node driver, and let libpq do its teardown
                client.connection ? client.connection.stream.destroy() : client.end();
            }, this.options.connectionTimeoutMillis);
        }
        this.log('connecting new client');
        client.connect((err)=>{
            if (tid) {
                clearTimeout(tid);
            }
            client.on('error', idleListener);
            if (err) {
                this.log('client failed to connect', err);
                // remove the dead client from our list of clients
                this._clients = this._clients.filter((c)=>c !== client);
                if (timeoutHit) {
                    err = new Error('Connection terminated due to connection timeout', {
                        cause: err
                    });
                }
                // this client wont be released, so move on immediately
                this._pulseQueue();
                if (!pendingItem.timedOut) {
                    pendingItem.callback(err, undefined, NOOP);
                }
            } else {
                this.log('new client connected');
                if (this.options.maxLifetimeSeconds !== 0) {
                    const maxLifetimeTimeout = setTimeout(()=>{
                        this.log('ending client due to expired lifetime');
                        this._expired.add(client);
                        const idleIndex = this._idle.findIndex((idleItem)=>idleItem.client === client);
                        if (idleIndex !== -1) {
                            this._acquireClient(client, new PendingItem((err, client, clientRelease)=>clientRelease()), idleListener, false);
                        }
                    }, this.options.maxLifetimeSeconds * 1000);
                    maxLifetimeTimeout.unref();
                    client.once('end', ()=>clearTimeout(maxLifetimeTimeout));
                }
                return this._acquireClient(client, pendingItem, idleListener, true);
            }
        });
    }
    // acquire a client for a pending work item
    _acquireClient(client, pendingItem, idleListener, isNew) {
        if (isNew) {
            this.emit('connect', client);
        }
        this.emit('acquire', client);
        client.release = this._releaseOnce(client, idleListener);
        client.removeListener('error', idleListener);
        if (!pendingItem.timedOut) {
            if (isNew && this.options.verify) {
                this.options.verify(client, (err)=>{
                    if (err) {
                        client.release(err);
                        return pendingItem.callback(err, undefined, NOOP);
                    }
                    pendingItem.callback(undefined, client, client.release);
                });
            } else {
                pendingItem.callback(undefined, client, client.release);
            }
        } else {
            if (isNew && this.options.verify) {
                this.options.verify(client, client.release);
            } else {
                client.release();
            }
        }
    }
    // returns a function that wraps _release and throws if called more than once
    _releaseOnce(client, idleListener) {
        let released = false;
        return (err)=>{
            if (released) {
                throwOnDoubleRelease();
            }
            released = true;
            this._release(client, idleListener, err);
        };
    }
    // release a client back to the poll, include an error
    // to remove it from the pool
    _release(client, idleListener, err) {
        client.on('error', idleListener);
        client._poolUseCount = (client._poolUseCount || 0) + 1;
        this.emit('release', err, client);
        // TODO(bmc): expose a proper, public interface _queryable and _ending
        if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
            if (client._poolUseCount >= this.options.maxUses) {
                this.log('remove expended client');
            }
            return this._remove(client, this._pulseQueue.bind(this));
        }
        const isExpired = this._expired.has(client);
        if (isExpired) {
            this.log('remove expired client');
            this._expired.delete(client);
            return this._remove(client, this._pulseQueue.bind(this));
        }
        // idle timeout
        let tid;
        if (this.options.idleTimeoutMillis && this._isAboveMin()) {
            tid = setTimeout(()=>{
                if (this._isAboveMin()) {
                    this.log('remove idle client');
                    this._remove(client, this._pulseQueue.bind(this));
                }
            }, this.options.idleTimeoutMillis);
            if (this.options.allowExitOnIdle) {
                // allow Node to exit if this is all that's left
                tid.unref();
            }
        }
        if (this.options.allowExitOnIdle) {
            client.unref();
        }
        this._idle.push(new IdleItem(client, idleListener, tid));
        this._pulseQueue();
    }
    query(text, values, cb) {
        // guard clause against passing a function as the first parameter
        if (typeof text === 'function') {
            const response = promisify(this.Promise, text);
            setImmediate(function() {
                return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'));
            });
            return response.result;
        }
        // allow plain text query without values
        if (typeof values === 'function') {
            cb = values;
            values = undefined;
        }
        const response = promisify(this.Promise, cb);
        cb = response.callback;
        this.connect((err, client)=>{
            if (err) {
                return cb(err);
            }
            let clientReleased = false;
            const onError = (err)=>{
                if (clientReleased) {
                    return;
                }
                clientReleased = true;
                client.release(err);
                cb(err);
            };
            client.once('error', onError);
            this.log('dispatching query');
            try {
                client.query(text, values, (err, res)=>{
                    this.log('query dispatched');
                    client.removeListener('error', onError);
                    if (clientReleased) {
                        return;
                    }
                    clientReleased = true;
                    client.release(err);
                    if (err) {
                        return cb(err);
                    }
                    return cb(undefined, res);
                });
            } catch (err) {
                client.release(err);
                return cb(err);
            }
        });
        return response.result;
    }
    end(cb) {
        this.log('ending');
        if (this.ending) {
            const err = new Error('Called end on pool more than once');
            return cb ? cb(err) : this.Promise.reject(err);
        }
        this.ending = true;
        const promised = promisify(this.Promise, cb);
        this._endCallback = promised.callback;
        this._pulseQueue();
        return promised.result;
    }
    get waitingCount() {
        return this._pendingQueue.length;
    }
    get idleCount() {
        return this._idle.length;
    }
    get expiredCount() {
        return this._clients.reduce((acc, client)=>acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
        return this._clients.length;
    }
}
module.exports = Pool;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/with-connection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.withConnection = void 0;
function withConnection(log, f) {
    return async (client)=>{
        try {
            try {
                log("Connecting to database...");
                await client.connect();
                log("... connected to database");
            } catch (e) {
                log(`Error connecting to database: ${e.message}`);
                throw e;
            }
            const result = await f(client);
            return result;
        } catch (e) {
            log(`Error using connection: ${e.message}`);
            throw e;
        } finally{
            // always try to close the connection
            try {
                log("Closing connection...");
                await client.end();
                log("... connection closed");
            } catch (e) {
                log(`Error closing the connection: ${e.message}`);
            }
        }
    };
}
exports.withConnection = withConnection;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/create.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.runSchemaQuery = exports.runCreateQuery = exports.createDb = void 0;
const pg = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/index.js [app-route] (ecmascript)");
const with_connection_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/with-connection.js [app-route] (ecmascript)");
const DUPLICATE_DATABASE = "42P04";
/**
 * @deprecated Use `migrate` instead with `ensureDatabaseExists: true`.
 */ async function createDb(dbName, dbConfig, config = {}) {
    if (typeof dbName !== "string") {
        throw new Error("Must pass database name as a string");
    }
    const log = config.logger != null ? config.logger : ()=>{
    //
    };
    if (dbConfig == null) {
        throw new Error("No config object");
    }
    if ("client" in dbConfig) {
        return runCreateQuery(dbName, log)(dbConfig.client);
    }
    if (typeof dbConfig.user !== "string" || typeof dbConfig.password !== "string" || typeof dbConfig.host !== "string" || typeof dbConfig.port !== "number") {
        throw new Error("Database config problem");
    }
    const { user, password, host, port } = dbConfig;
    const client = new pg.Client({
        database: dbConfig.defaultDatabase != null ? dbConfig.defaultDatabase : "postgres",
        user,
        password,
        host,
        port
    });
    client.on("error", (err)=>{
        log(`pg client emitted an error: ${err.message}`);
    });
    const runWith = with_connection_1.withConnection(log, runCreateQuery(dbName, log));
    return runWith(client);
}
exports.createDb = createDb;
function runCreateQuery(dbName, log) {
    return async (client)=>{
        await client.query(`CREATE DATABASE "${dbName.replace(/\"/g, '""')}"`).catch((e)=>{
            switch(e.code){
                case DUPLICATE_DATABASE:
                    {
                        log(`'${dbName}' database already exists`);
                        return;
                    }
                default:
                    {
                        log(e);
                        throw new Error(`Error creating database. Caused by: '${e.name}: ${e.message}'`);
                    }
            }
        });
    };
}
exports.runCreateQuery = runCreateQuery;
function runSchemaQuery(schemaName, log) {
    return async (client)=>{
        await client.query(`CREATE SCHEMA IF NOT EXISTS ${schemaName}`).catch((e)=>{
            log(`'${schemaName}' scheme already exists`);
        });
    };
}
exports.runSchemaQuery = runSchemaQuery;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/load-sql-from-js.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadSqlFromJs = void 0;
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const loadSqlFromJs = (filePath)=>{
    const migrationModule = (()=>{
        const e = new Error("Cannot find module as expression is too dynamic");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })();
    if (!migrationModule.generateSql) {
        throw new Error(`Invalid javascript migration file: '${path.basename(filePath)}'.
It must to export a 'generateSql' function.`);
    }
    const generatedValue = migrationModule.generateSql();
    if (typeof generatedValue !== "string") {
        throw new Error(`Invalid javascript migration file: '${path.basename(filePath)}'.
'generateSql' function must return a string literal.`);
    }
    return generatedValue;
};
exports.loadSqlFromJs = loadSqlFromJs;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/file-name-parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseFileName = void 0;
const parseId = (id)=>{
    const parsed = parseInt(id, 10);
    if (isNaN(parsed)) {
        throw new Error(`Migration file name should begin with an integer ID.'`);
    }
    return parsed;
};
const parseFileName = (fileName)=>{
    const result = /^(-?\d+)[-_]?(.*).(sql|js)$/gi.exec(fileName);
    if (!result) {
        throw new Error(`Invalid file name: '${fileName}'.`);
    }
    const [, id, name, type] = result;
    const lowerType = type.toLowerCase();
    if (lowerType !== "js" && lowerType !== "sql") {
        throw new Error("Not a JS or SQL file");
    }
    return {
        id: parseId(id),
        name: name == null || name === "" ? fileName : name,
        type: lowerType
    };
};
exports.parseFileName = parseFileName;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/migration-file.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadMigrationFile = void 0;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const load_sql_from_js_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/load-sql-from-js.js [app-route] (ecmascript)");
const file_name_parser_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/file-name-parser.js [app-route] (ecmascript)");
const readFile = util_1.promisify(fs.readFile);
const getFileName = (filePath)=>path.basename(filePath);
const getFileContents = async (filePath)=>readFile(filePath, "utf8");
const hashString = (s)=>crypto.createHash("sha1").update(s, "utf8").digest("hex");
const getSqlStringLiteral = (filePath, contents, type)=>{
    switch(type){
        case "sql":
            return contents;
        case "js":
            return load_sql_from_js_1.loadSqlFromJs(filePath);
        default:
            {
                const exhaustiveCheck = type;
                return exhaustiveCheck;
            }
    }
};
const loadMigrationFile = async (filePath)=>{
    const fileName = getFileName(filePath);
    try {
        const { id, name, type } = file_name_parser_1.parseFileName(fileName);
        const contents = await getFileContents(filePath);
        const sql = getSqlStringLiteral(filePath, contents, type);
        const hash = hashString(fileName + sql);
        return {
            id,
            name,
            contents,
            fileName,
            hash,
            sql
        };
    } catch (err) {
        throw new Error(`${err.message} - Offending file: '${fileName}'.`);
    }
};
exports.loadMigrationFile = loadMigrationFile;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/validation.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateMigrationHashes = exports.validateMigrationOrdering = void 0;
const indexNotMatch = (migration, index)=>migration.id !== index;
/** Assert migration IDs are consecutive integers */ function validateMigrationOrdering(migrations) {
    const notMatchingId = migrations.find(indexNotMatch);
    if (notMatchingId) {
        throw new Error(`Found a non-consecutive migration ID on file: '${notMatchingId.fileName}'`);
    }
}
exports.validateMigrationOrdering = validateMigrationOrdering;
/** Assert hashes match */ function validateMigrationHashes(migrations, appliedMigrations) {
    const invalidHash = (migration)=>{
        const appliedMigration = appliedMigrations[migration.id];
        return appliedMigration != null && appliedMigration.hash !== migration.hash;
    };
    // Assert migration hashes are still same
    const invalidHashes = migrations.filter(invalidHash);
    if (invalidHashes.length > 0) {
        // Someone has altered one or more migrations which has already run - gasp!
        const invalidFiles = invalidHashes.map(({ fileName })=>fileName);
        throw new Error(`Hashes don't match for migrations '${invalidFiles}'.
This means that the scripts have changed since it was applied.`);
    }
}
exports.validateMigrationHashes = validateMigrationHashes;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/files-loader.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadMigrationFiles = void 0;
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const migration_file_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/migration-file.js [app-route] (ecmascript)");
const validation_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/validation.js [app-route] (ecmascript)");
const readDir = util_1.promisify(fs.readdir);
const isValidFile = (fileName)=>/\.(sql|js)$/gi.test(fileName);
/**
 * Load the migration files and assert they are reasonably valid.
 *
 * 'Reasonably valid' in this case means obeying the file name and
 * consecutive ordering rules.
 *
 * No assertions are made about the validity of the SQL.
 */ const loadMigrationFiles = async (directory, // tslint:disable-next-line no-empty
log = ()=>{})=>{
    log(`Loading migrations from: ${directory}`);
    const fileNames = await readDir(directory);
    log(`Found migration files: ${fileNames}`);
    if (fileNames == null) {
        return [];
    }
    const migrationFiles = [
        ...fileNames.map((fileName)=>path.resolve(directory, fileName))
    ].filter(isValidFile);
    const unorderedMigrations = await Promise.all(migrationFiles.map(migration_file_1.loadMigrationFile));
    // Arrange in ID order
    const orderedMigrations = unorderedMigrations.sort((a, b)=>a.id - b.id);
    validation_1.validateMigrationOrdering(orderedMigrations);
    return orderedMigrations;
};
exports.loadMigrationFiles = loadMigrationFiles;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/run-migration.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.runMigration = void 0;
const sql_template_strings_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/sql-template-strings@2.2.2/node_modules/sql-template-strings/index.js [app-route] (ecmascript)");
const noop = ()=>{
//
};
const insertMigration = async (migrationTableName = 'migrations', migrationSchemaName = 'public', client, migration, log)=>{
    log(`Saving migration to '${migrationSchemaName}.${migrationTableName}': ${migration.id} | ${migration.name} | ${migration.hash}`);
    const sql = sql_template_strings_1.default`INSERT INTO `.append(`${migrationSchemaName}.${migrationTableName}`).append(sql_template_strings_1.default` ("id", "name", "hash") VALUES (${migration.id},${migration.name},${migration.hash})`);
    return client.query(sql);
};
const runMigration = (migrationTableName = 'migrations', migrationSchemaName = 'public', client, log = noop)=>async (migration)=>{
        const inTransaction = migration.sql.includes("-- postgres-migrations disable-transaction") === false;
        log(`Running migration in transaction: ${inTransaction}`);
        const begin = inTransaction ? ()=>client.query("START TRANSACTION") : noop;
        const end = inTransaction ? ()=>client.query("COMMIT") : noop;
        const cleanup = inTransaction ? ()=>client.query("ROLLBACK") : noop;
        try {
            await begin();
            await client.query(migration.sql);
            await insertMigration(migrationTableName, migrationSchemaName, client, migration, log);
            await end();
            return migration;
        } catch (err) {
            try {
                await cleanup();
            } catch (_a) {
            //
            }
            throw new Error(`An error occurred running '${migration.name}'. Rolled back this migration. No further migrations were run. Reason: ${err.message}`);
        }
    };
exports.runMigration = runMigration;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/with-lock.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.withAdvisoryLock = void 0;
function withAdvisoryLock(log, f) {
    return async (client)=>{
        try {
            try {
                log("Acquiring advisory lock...");
                let acquired = false;
                while(!acquired){
                    const lockResult = await client.query("SELECT pg_try_advisory_lock(-8525285245963000605);");
                    if (lockResult.rows[0].pg_try_advisory_lock === true) {
                        acquired = true;
                    } else {
                        await new Promise((res)=>setTimeout(res, 1000));
                    }
                }
                log("... acquired advisory lock");
            } catch (e) {
                log(`Error acquiring advisory lock: ${e.message}`);
                throw e;
            }
            const result = await f(client);
            return result;
        } catch (e) {
            log(`Error while using lock: ${e.message}`);
            throw e;
        } finally{
            try {
                log("Releasing advisory lock...");
                await client.query("SELECT pg_advisory_unlock(-8525285245963000605);");
                log("... released advisory lock");
            } catch (e) {
                log(`Error releasing advisory lock: ${e.message}`);
            }
        }
    };
}
exports.withAdvisoryLock = withAdvisoryLock;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/migrate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.migrate = void 0;
const pg = __turbopack_context__.r("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/lib/index.js [app-route] (ecmascript)");
const sql_template_strings_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/sql-template-strings@2.2.2/node_modules/sql-template-strings/index.js [app-route] (ecmascript)");
const create_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/create.js [app-route] (ecmascript)");
const files_loader_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/files-loader.js [app-route] (ecmascript)");
const run_migration_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/run-migration.js [app-route] (ecmascript)");
const validation_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/validation.js [app-route] (ecmascript)");
const with_connection_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/with-connection.js [app-route] (ecmascript)");
const with_lock_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/with-lock.js [app-route] (ecmascript)");
/**
 * Run the migrations.
 *
 * If `dbConfig.ensureDatabaseExists` is true then `dbConfig.database` will be created if it
 * does not exist.
 *
 * @param dbConfig Details about how to connect to the database
 * @param migrationsDirectory Directory containing the SQL migration files
 * @param config Extra configuration
 * @returns Details about the migrations which were run
 */ async function migrate(dbConfig, migrationsDirectory, config = {}) {
    const log = config.logger != null ? config.logger : ()=>{
    //
    };
    const options = {
        tableName: "tableName" in config && config.tableName !== undefined ? config.tableName : 'migrations',
        schemaName: "schemaName" in config && config.schemaName !== undefined ? config.schemaName : 'public'
    };
    if (dbConfig == null) {
        throw new Error("No config object");
    }
    if (typeof migrationsDirectory !== "string") {
        throw new Error("Must pass migrations directory as a string");
    }
    const intendedMigrations = await files_loader_1.loadMigrationFiles(migrationsDirectory, log);
    if ("client" in dbConfig) {
        // we have been given a client to use, it should already be connected
        return with_lock_1.withAdvisoryLock(log, runMigrations(intendedMigrations, log, options))(dbConfig.client);
    }
    if (typeof dbConfig.database !== "string" || typeof dbConfig.user !== "string" || typeof dbConfig.password !== "string" || typeof dbConfig.host !== "string" || typeof dbConfig.port !== "number") {
        throw new Error("Database config problem");
    }
    if (dbConfig.ensureDatabaseExists === true) {
        // Check whether database exists
        const { user, password, host, port } = dbConfig;
        const client = new pg.Client({
            database: dbConfig.defaultDatabase != null ? dbConfig.defaultDatabase : "postgres",
            user,
            password,
            host,
            port
        });
        const runWith = with_connection_1.withConnection(log, async (connectedClient)=>{
            const result = await connectedClient.query({
                text: "SELECT 1 FROM pg_database WHERE datname=$1",
                values: [
                    dbConfig.database
                ]
            });
            if (result.rowCount !== 1) {
                await create_1.runCreateQuery(dbConfig.database, log)(connectedClient);
            }
        });
        await runWith(client);
        // ---
        const runWith1 = with_connection_1.withConnection(log, async (connectedClient)=>{
            await create_1.runSchemaQuery(options.schemaName, log)(connectedClient);
        });
        await runWith1(client);
    }
    {
        const client = new pg.Client(dbConfig);
        client.on("error", (err)=>{
            log(`pg client emitted an error: ${err.message}`);
        });
        const runWith = with_connection_1.withConnection(log, with_lock_1.withAdvisoryLock(log, runMigrations(intendedMigrations, log, options)));
        return runWith(client);
    }
}
exports.migrate = migrate;
function runMigrations(intendedMigrations, log, options) {
    return async (client)=>{
        try {
            log(`Starting migrations against schema ${options.schemaName}`);
            const appliedMigrations = await fetchAppliedMigrationFromDB(options.tableName, options.schemaName, client, log);
            validation_1.validateMigrationHashes(intendedMigrations, appliedMigrations);
            const migrationsToRun = filterMigrations(intendedMigrations, appliedMigrations);
            const completedMigrations = [];
            for (const migration of migrationsToRun){
                log(`Starting migration: ${migration.id} ${migration.name}`);
                const result = await run_migration_1.runMigration(options.tableName, options.schemaName, client, log)(migration);
                log(`Finished migration: ${migration.id} ${migration.name}`);
                completedMigrations.push(result);
            }
            logResult(completedMigrations, log);
            log("Finished migrations");
            return completedMigrations;
        } catch (e) {
            const error = new Error(`Migration failed. Reason: ${e.message}`);
            error.cause = e.message;
            throw error;
        }
    };
}
/** Queries the database for migrations table and retrieve it rows if exists */ async function fetchAppliedMigrationFromDB(migrationTableName, migrationSchemaName, client, log) {
    let appliedMigrations = [];
    if (await doesTableExist(client, migrationTableName, migrationSchemaName)) {
        log(`Migrations table with name '${migrationSchemaName}.${migrationTableName}' exists, filtering not applied migrations.`);
        const { rows } = await client.query(`SELECT * FROM ${migrationSchemaName}.${migrationTableName} ORDER BY id`);
        appliedMigrations = rows;
    } else {
        await client.query(`
        CREATE TABLE IF NOT EXISTS ${migrationSchemaName}.${migrationTableName} (
          id integer PRIMARY KEY,
          name varchar(100) UNIQUE NOT NULL,
          hash varchar(40) NOT NULL, -- sha1 hex encoded hash of the file name and contents, to ensure it hasn't been altered since applying the migration
          executed_at timestamp DEFAULT current_timestamp
        );
    `);
        log(`Migrations table with name '${migrationSchemaName}.${migrationTableName}' has been created!`);
    }
    return appliedMigrations;
}
/** Work out which migrations to apply */ function filterMigrations(migrations, appliedMigrations) {
    const notAppliedMigration = (migration)=>!appliedMigrations[migration.id];
    return migrations.filter(notAppliedMigration);
}
/** Logs the result */ function logResult(completedMigrations, log) {
    if (completedMigrations.length === 0) {
        log("No migrations applied");
    } else {
        log(`Successfully applied migrations: ${completedMigrations.map(({ name })=>name)}`);
    }
}
/** Check whether table exists in postgres - http://stackoverflow.com/a/24089729 */ async function doesTableExist(client, tableName, schemaName) {
    const result = await client.query(sql_template_strings_1.default`SELECT EXISTS (
    SELECT 1
    FROM information_schema.tables
    WHERE table_schema = ${schemaName}
    AND table_name = ${tableName}
  );`);
    return result.rows.length > 0 && result.rows[0].exists;
}
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MigrationError = void 0;
class MigrationError extends Error {
}
exports.MigrationError = MigrationError;
}),
"[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MigrationError = exports.loadMigrationFiles = exports.migrate = exports.createDb = void 0;
var create_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/create.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createDb", {
    enumerable: true,
    get: function() {
        return create_1.createDb;
    }
});
var migrate_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/migrate.js [app-route] (ecmascript)");
Object.defineProperty(exports, "migrate", {
    enumerable: true,
    get: function() {
        return migrate_1.migrate;
    }
});
var files_loader_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/files-loader.js [app-route] (ecmascript)");
Object.defineProperty(exports, "loadMigrationFiles", {
    enumerable: true,
    get: function() {
        return files_loader_1.loadMigrationFiles;
    }
});
var types_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/types.js [app-route] (ecmascript)");
Object.defineProperty(exports, "MigrationError", {
    enumerable: true,
    get: function() {
        return types_1.MigrationError;
    }
});
}),
"[project]/node_modules/.pnpm/sql-template-strings@2.2.2/node_modules/sql-template-strings/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

class SQLStatement {
    /**
   * @param {string[]} strings
   * @param {any[]} values
   */ constructor(strings, values){
        this.strings = strings;
        this.values = values;
    }
    /** Returns the SQL Statement for Sequelize */ get query() {
        return this.bind ? this.text : this.sql;
    }
    /** Returns the SQL Statement for node-postgres */ get text() {
        return this.strings.reduce((prev, curr, i)=>prev + '$' + i + curr);
    }
    /**
   * @param {SQLStatement|string} statement
   * @returns {this}
   */ append(statement) {
        if (statement instanceof SQLStatement) {
            this.strings[this.strings.length - 1] += statement.strings[0];
            this.strings.push.apply(this.strings, statement.strings.slice(1));
            (this.values || this.bind).push.apply(this.values, statement.values);
        } else {
            this.strings[this.strings.length - 1] += statement;
        }
        return this;
    }
    /**
   * Use a prepared statement with Sequelize.
   * Makes `query` return a query with `$n` syntax instead of `?`  and switches the `values` key name to `bind`
   * @param {boolean} [value=true] value If omitted, defaults to `true`
   * @returns this
   */ useBind(value) {
        if (value === undefined) {
            value = true;
        }
        if (value && !this.bind) {
            this.bind = this.values;
            delete this.values;
        } else if (!value && this.bind) {
            this.values = this.bind;
            delete this.bind;
        }
        return this;
    }
    /**
   * @param {string} name
   * @returns {this}
   */ setName(name) {
        this.name = name;
        return this;
    }
}
/** Returns the SQL Statement for mysql */ Object.defineProperty(SQLStatement.prototype, 'sql', {
    enumerable: true,
    get () {
        return this.strings.join('?');
    }
});
/**
 * @param {string[]} strings
 * @param {...any} values
 * @returns {SQLStatement}
 */ function SQL(strings) {
    return new SQLStatement(strings.slice(0), Array.from(arguments).slice(1));
}
module.exports = SQL;
module.exports.SQL = SQL;
module.exports.default = SQL;
module.exports.SQLStatement = SQLStatement;
}),
"[project]/node_modules/.pnpm/stripe-replit-sync@1.0.0_stripe@20.0.0_@types+node@22.19.8_/node_modules/stripe-replit-sync/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/stripeSync.ts
__turbopack_context__.s([
    "PostgresClient",
    ()=>PostgresClient,
    "StripeSync",
    ()=>StripeSync,
    "hashApiKey",
    ()=>hashApiKey,
    "runMigrations",
    ()=>runMigrations
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/stripe@20.0.0_@types+node@22.19.8/node_modules/stripe/esm/stripe.esm.node.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$yesql$40$7$2e$0$2e$0$2f$node_modules$2f$yesql$2f$yesql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/yesql@7.0.0/node_modules/yesql/yesql.js [app-route] (ecmascript)");
// src/database/postgres.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/pg@8.18.0/node_modules/pg/esm/index.mjs [app-route] (ecmascript)");
// src/utils/hashApiKey.ts
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$2d$node$2d$migrations$40$0$2e$0$2e$8$2f$node_modules$2f$pg$2d$node$2d$migrations$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/pg-node-migrations@0.0.8/node_modules/pg-node-migrations/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/url [external] (url, cjs)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/.pnpm/stripe-replit-sync@1.0.0_stripe@20.0.0_@types+node@22.19.8_/node_modules/stripe-replit-sync/dist/index.js")}`;
    }
};
;
;
;
;
var ORDERED_STRIPE_TABLES = [
    "subscription_items",
    "subscriptions",
    "subscription_schedules",
    "checkout_session_line_items",
    "checkout_sessions",
    "tax_ids",
    "charges",
    "refunds",
    "credit_notes",
    "disputes",
    "early_fraud_warnings",
    "invoices",
    "payment_intents",
    "payment_methods",
    "setup_intents",
    "prices",
    "plans",
    "products",
    "features",
    "active_entitlements",
    "reviews",
    "_managed_webhooks",
    "customers",
    "_sync_status"
];
var PostgresClient = class {
    constructor(config){
        this.config = config;
        this.pool = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Pool(config.poolConfig);
    }
    pool;
    async delete(table, id) {
        const prepared = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$yesql$40$7$2e$0$2e$0$2f$node_modules$2f$yesql$2f$yesql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pg"])(`
    delete from "${this.config.schema}"."${table}"
    where id = :id
    returning id;
    `)({
            id
        });
        const { rows } = await this.query(prepared.text, prepared.values);
        return rows.length > 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async query(text, params) {
        return this.pool.query(text, params);
    }
    async upsertMany(entries, table) {
        if (!entries.length) return [];
        const chunkSize = 5;
        const results = [];
        for(let i = 0; i < entries.length; i += chunkSize){
            const chunk = entries.slice(i, i + chunkSize);
            const queries = [];
            chunk.forEach((entry)=>{
                const rawData = JSON.stringify(entry);
                const upsertSql = `
          INSERT INTO "${this.config.schema}"."${table}" ("_raw_data")
          VALUES ($1::jsonb)
          ON CONFLICT (id)
          DO UPDATE SET
            "_raw_data" = EXCLUDED."_raw_data"
          RETURNING *
        `;
                queries.push(this.pool.query(upsertSql, [
                    rawData
                ]));
            });
            results.push(...await Promise.all(queries));
        }
        return results.flatMap((it)=>it.rows);
    }
    async upsertManyWithTimestampProtection(entries, table, accountId, syncTimestamp) {
        const timestamp = syncTimestamp || /* @__PURE__ */ new Date().toISOString();
        if (!entries.length) return [];
        const chunkSize = 5;
        const results = [];
        for(let i = 0; i < entries.length; i += chunkSize){
            const chunk = entries.slice(i, i + chunkSize);
            const queries = [];
            chunk.forEach((entry)=>{
                if (table.startsWith("_")) {
                    const columns = Object.keys(entry).filter((k)=>k !== "last_synced_at" && k !== "account_id");
                    const upsertSql = `
            INSERT INTO "${this.config.schema}"."${table}" (
              ${columns.map((c)=>`"${c}"`).join(", ")}, "last_synced_at", "account_id"
            )
            VALUES (
              ${columns.map((c)=>`:${c}`).join(", ")}, :last_synced_at, :account_id
            )
            ON CONFLICT ("id")
            DO UPDATE SET
              ${columns.map((c)=>`"${c}" = EXCLUDED."${c}"`).join(", ")},
              "last_synced_at" = :last_synced_at,
              "account_id" = EXCLUDED."account_id"
            WHERE "${table}"."last_synced_at" IS NULL
               OR "${table}"."last_synced_at" < :last_synced_at
            RETURNING *
          `;
                    const cleansed = this.cleanseArrayField(entry);
                    cleansed.last_synced_at = timestamp;
                    cleansed.account_id = accountId;
                    const prepared = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$yesql$40$7$2e$0$2e$0$2f$node_modules$2f$yesql$2f$yesql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pg"])(upsertSql, {
                        useNullForMissing: true
                    })(cleansed);
                    queries.push(this.pool.query(prepared.text, prepared.values));
                } else {
                    const rawData = JSON.stringify(entry);
                    const upsertSql = `
            INSERT INTO "${this.config.schema}"."${table}" ("_raw_data", "_last_synced_at", "_account_id")
            VALUES ($1::jsonb, $2, $3)
            ON CONFLICT (id)
            DO UPDATE SET
              "_raw_data" = EXCLUDED."_raw_data",
              "_last_synced_at" = $2,
              "_account_id" = EXCLUDED."_account_id"
            WHERE "${table}"."_last_synced_at" IS NULL
               OR "${table}"."_last_synced_at" < $2
            RETURNING *
          `;
                    queries.push(this.pool.query(upsertSql, [
                        rawData,
                        timestamp,
                        accountId
                    ]));
                }
            });
            results.push(...await Promise.all(queries));
        }
        return results.flatMap((it)=>it.rows);
    }
    cleanseArrayField(obj) {
        const cleansed = {
            ...obj
        };
        Object.keys(cleansed).map((k)=>{
            const data = cleansed[k];
            if (Array.isArray(data)) {
                cleansed[k] = JSON.stringify(data);
            }
        });
        return cleansed;
    }
    async findMissingEntries(table, ids) {
        if (!ids.length) return [];
        const prepared = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$yesql$40$7$2e$0$2e$0$2f$node_modules$2f$yesql$2f$yesql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pg"])(`
    select id from "${this.config.schema}"."${table}"
    where id=any(:ids::text[]);
    `)({
            ids
        });
        const { rows } = await this.query(prepared.text, prepared.values);
        const existingIds = rows.map((it)=>it.id);
        const missingIds = ids.filter((it)=>!existingIds.includes(it));
        return missingIds;
    }
    // Sync status tracking methods for incremental backfill
    async getSyncCursor(resource, accountId) {
        const result = await this.query(`SELECT EXTRACT(EPOCH FROM last_incremental_cursor)::integer as cursor
       FROM "${this.config.schema}"."_sync_status"
       WHERE resource = $1 AND "account_id" = $2`, [
            resource,
            accountId
        ]);
        const cursor = result.rows[0]?.cursor ?? null;
        return cursor;
    }
    async updateSyncCursor(resource, accountId, cursor) {
        await this.query(`INSERT INTO "${this.config.schema}"."_sync_status" (resource, "account_id", last_incremental_cursor, status, last_synced_at)
       VALUES ($1, $2, to_timestamp($3), 'running', now())
       ON CONFLICT (resource, "account_id")
       DO UPDATE SET
         last_incremental_cursor = GREATEST(
           COALESCE("${this.config.schema}"."_sync_status".last_incremental_cursor, to_timestamp(0)),
           to_timestamp($3)
         ),
         last_synced_at = now(),
         updated_at = now()`, [
            resource,
            accountId,
            cursor.toString()
        ]);
    }
    async markSyncRunning(resource, accountId) {
        await this.query(`INSERT INTO "${this.config.schema}"."_sync_status" (resource, "account_id", status)
       VALUES ($1, $2, 'running')
       ON CONFLICT (resource, "account_id")
       DO UPDATE SET status = 'running', updated_at = now()`, [
            resource,
            accountId
        ]);
    }
    async markSyncComplete(resource, accountId) {
        await this.query(`UPDATE "${this.config.schema}"."_sync_status"
       SET status = 'complete', error_message = NULL, updated_at = now()
       WHERE resource = $1 AND "account_id" = $2`, [
            resource,
            accountId
        ]);
    }
    async markSyncError(resource, accountId, errorMessage) {
        await this.query(`UPDATE "${this.config.schema}"."_sync_status"
       SET status = 'error', error_message = $3, updated_at = now()
       WHERE resource = $1 AND "account_id" = $2`, [
            resource,
            accountId,
            errorMessage
        ]);
    }
    // Account management methods
    async upsertAccount(accountData, apiKeyHash) {
        const rawData = JSON.stringify(accountData.raw_data);
        await this.query(`INSERT INTO "${this.config.schema}"."accounts" ("_raw_data", "api_key_hashes", "first_synced_at", "_last_synced_at")
       VALUES ($1::jsonb, ARRAY[$2], now(), now())
       ON CONFLICT (id)
       DO UPDATE SET
         "_raw_data" = EXCLUDED."_raw_data",
         "api_key_hashes" = (
           SELECT ARRAY(
             SELECT DISTINCT unnest(
               COALESCE("${this.config.schema}"."accounts"."api_key_hashes", '{}') || ARRAY[$2]
             )
           )
         ),
         "_last_synced_at" = now(),
         "_updated_at" = now()`, [
            rawData,
            apiKeyHash
        ]);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async getAllAccounts() {
        const result = await this.query(`SELECT _raw_data FROM "${this.config.schema}"."accounts"
       ORDER BY _last_synced_at DESC`);
        return result.rows.map((row)=>row._raw_data);
    }
    /**
   * Looks up an account ID by API key hash
   * Uses the GIN index on api_key_hashes for fast lookups
   * @param apiKeyHash - SHA-256 hash of the Stripe API key
   * @returns Account ID if found, null otherwise
   */ async getAccountIdByApiKeyHash(apiKeyHash) {
        const result = await this.query(`SELECT id FROM "${this.config.schema}"."accounts"
       WHERE $1 = ANY(api_key_hashes)
       LIMIT 1`, [
            apiKeyHash
        ]);
        return result.rows.length > 0 ? result.rows[0].id : null;
    }
    async getAccountRecordCounts(accountId) {
        const counts = {};
        for (const table of ORDERED_STRIPE_TABLES){
            const accountIdColumn = table.startsWith("_") ? "account_id" : "_account_id";
            const result = await this.query(`SELECT COUNT(*) as count FROM "${this.config.schema}"."${table}"
         WHERE "${accountIdColumn}" = $1`, [
                accountId
            ]);
            counts[table] = parseInt(result.rows[0].count);
        }
        return counts;
    }
    async deleteAccountWithCascade(accountId, useTransaction) {
        const deletionCounts = {};
        try {
            if (useTransaction) {
                await this.query("BEGIN");
            }
            for (const table of ORDERED_STRIPE_TABLES){
                const accountIdColumn = table.startsWith("_") ? "account_id" : "_account_id";
                const result = await this.query(`DELETE FROM "${this.config.schema}"."${table}"
           WHERE "${accountIdColumn}" = $1`, [
                    accountId
                ]);
                deletionCounts[table] = result.rowCount || 0;
            }
            const accountResult = await this.query(`DELETE FROM "${this.config.schema}"."accounts"
         WHERE "id" = $1`, [
                accountId
            ]);
            deletionCounts["accounts"] = accountResult.rowCount || 0;
            if (useTransaction) {
                await this.query("COMMIT");
            }
        } catch (error) {
            if (useTransaction) {
                await this.query("ROLLBACK");
            }
            throw error;
        }
        return deletionCounts;
    }
    /**
   * Hash a string to a 32-bit integer for use with PostgreSQL advisory locks.
   * Uses a simple hash algorithm that produces consistent results.
   */ hashToInt32(key) {
        let hash = 0;
        for(let i = 0; i < key.length; i++){
            const char = key.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
        }
        return hash;
    }
    /**
   * Acquire a PostgreSQL advisory lock for the given key.
   * This lock is automatically released when the connection is closed or explicitly released.
   * Advisory locks are session-level and will block until the lock is available.
   *
   * @param key - A string key to lock on (will be hashed to an integer)
   */ async acquireAdvisoryLock(key) {
        const lockId = this.hashToInt32(key);
        await this.query("SELECT pg_advisory_lock($1)", [
            lockId
        ]);
    }
    /**
   * Release a PostgreSQL advisory lock for the given key.
   *
   * @param key - The same string key used to acquire the lock
   */ async releaseAdvisoryLock(key) {
        const lockId = this.hashToInt32(key);
        await this.query("SELECT pg_advisory_unlock($1)", [
            lockId
        ]);
    }
    /**
   * Execute a function while holding an advisory lock.
   * The lock is automatically released after the function completes (success or error).
   *
   * IMPORTANT: This acquires a dedicated connection from the pool and holds it for the
   * duration of the function execution. PostgreSQL advisory locks are session-level,
   * so we must use the same connection for lock acquisition, operations, and release.
   *
   * @param key - A string key to lock on (will be hashed to an integer)
   * @param fn - The function to execute while holding the lock
   * @returns The result of the function
   */ async withAdvisoryLock(key, fn) {
        const lockId = this.hashToInt32(key);
        const client = await this.pool.connect();
        try {
            await client.query("SELECT pg_advisory_lock($1)", [
                lockId
            ]);
            return await fn();
        } finally{
            try {
                await client.query("SELECT pg_advisory_unlock($1)", [
                    lockId
                ]);
            } finally{
                client.release();
            }
        }
    }
};
// src/schemas/managed_webhook.ts
var managedWebhookSchema = {
    properties: [
        "id",
        "object",
        "url",
        "enabled_events",
        "description",
        "enabled",
        "livemode",
        "metadata",
        "secret",
        "status",
        "api_version",
        "created",
        "account_id"
    ]
};
;
var DEFAULT_RETRY_CONFIG = {
    maxRetries: 5,
    initialDelayMs: 1e3,
    // 1 second
    maxDelayMs: 6e4,
    // 60 seconds
    jitterMs: 500
};
function isRetryableError(error) {
    if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeRateLimitError) {
        return true;
    }
    if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeAPIError) {
        const statusCode = error.statusCode;
        if (statusCode && [
            500,
            502,
            503,
            504,
            424
        ].includes(statusCode)) {
            return true;
        }
    }
    if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeConnectionError) {
        return true;
    }
    return false;
}
function getRetryAfterMs(error) {
    if (!(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeRateLimitError)) {
        return null;
    }
    const retryAfterHeader = error.headers?.["retry-after"];
    if (!retryAfterHeader) {
        return null;
    }
    const retryAfterSeconds = Number(retryAfterHeader);
    if (isNaN(retryAfterSeconds) || retryAfterSeconds <= 0) {
        return null;
    }
    return retryAfterSeconds * 1e3;
}
function calculateDelay(attempt, config, retryAfterMs) {
    if (retryAfterMs !== null && retryAfterMs !== void 0) {
        const jitter2 = Math.random() * config.jitterMs;
        return retryAfterMs + jitter2;
    }
    const exponentialDelay = Math.min(config.initialDelayMs * Math.pow(2, attempt), config.maxDelayMs);
    const jitter = Math.random() * config.jitterMs;
    return exponentialDelay + jitter;
}
function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}
function getErrorType(error) {
    if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeRateLimitError) {
        return "rate_limit";
    }
    if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeAPIError) {
        return `api_error_${error.statusCode}`;
    }
    if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeConnectionError) {
        return "connection_error";
    }
    return "unknown";
}
async function withRetry(fn, config = {}, logger) {
    const retryConfig = {
        ...DEFAULT_RETRY_CONFIG,
        ...config
    };
    let lastError;
    for(let attempt = 0; attempt <= retryConfig.maxRetries; attempt++){
        try {
            return await fn();
        } catch (error) {
            lastError = error;
            if (!isRetryableError(error)) {
                throw error;
            }
            if (attempt >= retryConfig.maxRetries) {
                logger?.error({
                    error: error instanceof Error ? error.message : String(error),
                    errorType: getErrorType(error),
                    attempt: attempt + 1,
                    maxRetries: retryConfig.maxRetries
                }, "Max retries exhausted for Stripe error");
                throw error;
            }
            const retryAfterMs = getRetryAfterMs(error);
            const delay = calculateDelay(attempt, retryConfig, retryAfterMs);
            logger?.warn({
                error: error instanceof Error ? error.message : String(error),
                errorType: getErrorType(error),
                attempt: attempt + 1,
                maxRetries: retryConfig.maxRetries,
                delayMs: Math.round(delay),
                retryAfterMs: retryAfterMs ?? void 0,
                nextAttempt: attempt + 2
            }, "Transient Stripe error, retrying after delay");
            await sleep(delay);
        }
    }
    throw lastError;
}
// src/utils/stripeClientWrapper.ts
function createRetryableStripeClient(stripe, retryConfig = {}, logger) {
    const isTest = ("TURBOPACK compile-time value", "development") === "test" || process.env.VITEST === "true" || process.env.JEST_WORKER_ID !== void 0;
    if (isTest) {
        return stripe;
    }
    return new Proxy(stripe, {
        get (target, prop, receiver) {
            const original = Reflect.get(target, prop, receiver);
            if (original && typeof original === "object" && !isPromise(original)) {
                return wrapResource(original, retryConfig, logger);
            }
            return original;
        }
    });
}
function wrapResource(resource, retryConfig, logger) {
    return new Proxy(resource, {
        get (target, prop, receiver) {
            const original = Reflect.get(target, prop, receiver);
            if (typeof original === "function") {
                return function(...args) {
                    const result = original.apply(target, args);
                    if (result && typeof result === "object" && Symbol.asyncIterator in result) {
                        return result;
                    }
                    if (isPromise(result)) {
                        return withRetry(()=>Promise.resolve(result), retryConfig, logger);
                    }
                    return result;
                };
            }
            if (original && typeof original === "object" && !isPromise(original)) {
                return wrapResource(original, retryConfig, logger);
            }
            return original;
        }
    });
}
function isPromise(value) {
    return value !== null && typeof value === "object" && typeof value.then === "function";
}
;
function hashApiKey(apiKey) {
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createHash"])("sha256").update(apiKey).digest("hex");
}
// src/stripeSync.ts
function getUniqueIds(entries, key) {
    const set = new Set(entries.map((subscription)=>subscription?.[key]?.toString()).filter((it)=>Boolean(it)));
    return Array.from(set);
}
var StripeSync = class {
    constructor(config){
        this.config = config;
        const baseStripe = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](config.stripeSecretKey, {
            // https://github.com/stripe/stripe-node#configuration
            // @ts-ignore
            apiVersion: config.stripeApiVersion,
            appInfo: {
                name: "Stripe Postgres Sync"
            }
        });
        this.stripe = createRetryableStripeClient(baseStripe, {}, config.logger);
        this.config.logger = config.logger ?? console;
        this.config.logger?.info({
            autoExpandLists: config.autoExpandLists,
            stripeApiVersion: config.stripeApiVersion
        }, "StripeSync initialized");
        const poolConfig = config.poolConfig ?? {};
        if (config.databaseUrl) {
            poolConfig.connectionString = config.databaseUrl;
        }
        if (config.maxPostgresConnections) {
            poolConfig.max = config.maxPostgresConnections;
        }
        if (poolConfig.max === void 0) {
            poolConfig.max = 10;
        }
        if (poolConfig.keepAlive === void 0) {
            poolConfig.keepAlive = true;
        }
        this.postgresClient = new PostgresClient({
            schema: "stripe",
            poolConfig
        });
    }
    stripe;
    postgresClient;
    cachedAccount = null;
    /**
   * Get the Stripe account ID. Uses database lookup by API key hash for fast lookups,
   * with fallback to Stripe API if not found (first-time setup or new API key).
   */ async getAccountId(objectAccountId) {
        if (this.cachedAccount?.id) {
            return this.cachedAccount.id;
        }
        const apiKeyHash = hashApiKey(this.config.stripeSecretKey);
        try {
            const accountId = await this.postgresClient.getAccountIdByApiKeyHash(apiKeyHash);
            if (accountId) {
                return accountId;
            }
        } catch (error) {
            this.config.logger?.warn(error, "Failed to lookup account by API key hash, falling back to API");
        }
        let account;
        try {
            const accountIdParam = objectAccountId || this.config.stripeAccountId;
            account = accountIdParam ? await this.stripe.accounts.retrieve(accountIdParam) : await this.stripe.accounts.retrieve();
        } catch (error) {
            this.config.logger?.error(error, "Failed to retrieve account from Stripe API");
            throw new Error("Failed to retrieve Stripe account. Please ensure API key is valid.");
        }
        this.cachedAccount = account;
        await this.upsertAccount(account, apiKeyHash);
        return account.id;
    }
    /**
   * Upsert Stripe account information to the database
   * @param account - Stripe account object
   * @param apiKeyHash - SHA-256 hash of API key to store for fast lookups
   */ async upsertAccount(account, apiKeyHash) {
        try {
            await this.postgresClient.upsertAccount({
                id: account.id,
                raw_data: account
            }, apiKeyHash);
        } catch (error) {
            this.config.logger?.error(error, "Failed to upsert account to database");
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            throw new Error(`Failed to upsert account to database: ${errorMessage}`);
        }
    }
    /**
   * Get the current account being synced
   */ async getCurrentAccount() {
        if (this.cachedAccount) {
            return this.cachedAccount;
        }
        await this.getAccountId();
        return this.cachedAccount;
    }
    /**
   * Get all accounts that have been synced to the database
   */ async getAllSyncedAccounts() {
        try {
            const accountsData = await this.postgresClient.getAllAccounts();
            return accountsData;
        } catch (error) {
            this.config.logger?.error(error, "Failed to retrieve accounts from database");
            throw new Error("Failed to retrieve synced accounts from database");
        }
    }
    /**
   * DANGEROUS: Delete an account and all associated data from the database
   * This operation cannot be undone!
   *
   * @param accountId - The Stripe account ID to delete
   * @param options - Options for deletion behavior
   * @param options.dryRun - If true, only count records without deleting (default: false)
   * @param options.useTransaction - If true, use transaction for atomic deletion (default: true)
   * @returns Deletion summary with counts and warnings
   */ async dangerouslyDeleteSyncedAccountData(accountId, options) {
        const dryRun = options?.dryRun ?? false;
        const useTransaction = options?.useTransaction ?? true;
        this.config.logger?.info(`${dryRun ? "Preview" : "Deleting"} account ${accountId} (transaction: ${useTransaction})`);
        try {
            const counts = await this.postgresClient.getAccountRecordCounts(accountId);
            const warnings = [];
            let totalRecords = 0;
            for (const [table, count] of Object.entries(counts)){
                if (count > 0) {
                    totalRecords += count;
                    warnings.push(`Will delete ${count} ${table} record${count !== 1 ? "s" : ""}`);
                }
            }
            if (totalRecords > 1e5) {
                warnings.push(`Large dataset detected (${totalRecords} total records). Consider using useTransaction: false for better performance.`);
            }
            if (this.cachedAccount?.id === accountId) {
                warnings.push("Warning: Deleting the current account. Cache will be cleared after deletion.");
            }
            if (dryRun) {
                this.config.logger?.info(`Dry-run complete: ${totalRecords} total records would be deleted`);
                return {
                    deletedAccountId: accountId,
                    deletedRecordCounts: counts,
                    warnings
                };
            }
            const deletionCounts = await this.postgresClient.deleteAccountWithCascade(accountId, useTransaction);
            if (this.cachedAccount?.id === accountId) {
                this.cachedAccount = null;
            }
            this.config.logger?.info(`Successfully deleted account ${accountId} with ${totalRecords} total records`);
            return {
                deletedAccountId: accountId,
                deletedRecordCounts: deletionCounts,
                warnings
            };
        } catch (error) {
            this.config.logger?.error(error, `Failed to delete account ${accountId}`);
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            throw new Error(`Failed to delete account ${accountId}: ${errorMessage}`);
        }
    }
    async processWebhook(payload, signature) {
        let webhookSecret = this.config.stripeWebhookSecret;
        if (!webhookSecret) {
            const accountId = await this.getAccountId();
            const result = await this.postgresClient.query(`SELECT secret FROM "stripe"."_managed_webhooks" WHERE account_id = $1 LIMIT 1`, [
                accountId
            ]);
            if (result.rows.length > 0) {
                webhookSecret = result.rows[0].secret;
            }
        }
        if (!webhookSecret) {
            throw new Error("No webhook secret provided. Either create a managed webhook or configure stripeWebhookSecret.");
        }
        const event = await this.stripe.webhooks.constructEventAsync(payload, signature, webhookSecret);
        return this.processEvent(event);
    }
    // Event handler registry - maps event types to handler functions
    // Note: Uses 'any' for event parameter to allow handlers with specific Stripe event types
    // (e.g., CustomerDeletedEvent, ProductDeletedEvent) which TypeScript won't accept
    // as contravariant parameters when using the base Stripe.Event type
    eventHandlers = {
        "charge.captured": this.handleChargeEvent.bind(this),
        "charge.expired": this.handleChargeEvent.bind(this),
        "charge.failed": this.handleChargeEvent.bind(this),
        "charge.pending": this.handleChargeEvent.bind(this),
        "charge.refunded": this.handleChargeEvent.bind(this),
        "charge.succeeded": this.handleChargeEvent.bind(this),
        "charge.updated": this.handleChargeEvent.bind(this),
        "customer.deleted": this.handleCustomerDeletedEvent.bind(this),
        "customer.created": this.handleCustomerEvent.bind(this),
        "customer.updated": this.handleCustomerEvent.bind(this),
        "checkout.session.async_payment_failed": this.handleCheckoutSessionEvent.bind(this),
        "checkout.session.async_payment_succeeded": this.handleCheckoutSessionEvent.bind(this),
        "checkout.session.completed": this.handleCheckoutSessionEvent.bind(this),
        "checkout.session.expired": this.handleCheckoutSessionEvent.bind(this),
        "customer.subscription.created": this.handleSubscriptionEvent.bind(this),
        "customer.subscription.deleted": this.handleSubscriptionEvent.bind(this),
        "customer.subscription.paused": this.handleSubscriptionEvent.bind(this),
        "customer.subscription.pending_update_applied": this.handleSubscriptionEvent.bind(this),
        "customer.subscription.pending_update_expired": this.handleSubscriptionEvent.bind(this),
        "customer.subscription.trial_will_end": this.handleSubscriptionEvent.bind(this),
        "customer.subscription.resumed": this.handleSubscriptionEvent.bind(this),
        "customer.subscription.updated": this.handleSubscriptionEvent.bind(this),
        "customer.tax_id.updated": this.handleTaxIdEvent.bind(this),
        "customer.tax_id.created": this.handleTaxIdEvent.bind(this),
        "customer.tax_id.deleted": this.handleTaxIdDeletedEvent.bind(this),
        "invoice.created": this.handleInvoiceEvent.bind(this),
        "invoice.deleted": this.handleInvoiceEvent.bind(this),
        "invoice.finalized": this.handleInvoiceEvent.bind(this),
        "invoice.finalization_failed": this.handleInvoiceEvent.bind(this),
        "invoice.paid": this.handleInvoiceEvent.bind(this),
        "invoice.payment_action_required": this.handleInvoiceEvent.bind(this),
        "invoice.payment_failed": this.handleInvoiceEvent.bind(this),
        "invoice.payment_succeeded": this.handleInvoiceEvent.bind(this),
        "invoice.upcoming": this.handleInvoiceEvent.bind(this),
        "invoice.sent": this.handleInvoiceEvent.bind(this),
        "invoice.voided": this.handleInvoiceEvent.bind(this),
        "invoice.marked_uncollectible": this.handleInvoiceEvent.bind(this),
        "invoice.updated": this.handleInvoiceEvent.bind(this),
        "product.created": this.handleProductEvent.bind(this),
        "product.updated": this.handleProductEvent.bind(this),
        "product.deleted": this.handleProductDeletedEvent.bind(this),
        "price.created": this.handlePriceEvent.bind(this),
        "price.updated": this.handlePriceEvent.bind(this),
        "price.deleted": this.handlePriceDeletedEvent.bind(this),
        "plan.created": this.handlePlanEvent.bind(this),
        "plan.updated": this.handlePlanEvent.bind(this),
        "plan.deleted": this.handlePlanDeletedEvent.bind(this),
        "setup_intent.canceled": this.handleSetupIntentEvent.bind(this),
        "setup_intent.created": this.handleSetupIntentEvent.bind(this),
        "setup_intent.requires_action": this.handleSetupIntentEvent.bind(this),
        "setup_intent.setup_failed": this.handleSetupIntentEvent.bind(this),
        "setup_intent.succeeded": this.handleSetupIntentEvent.bind(this),
        "subscription_schedule.aborted": this.handleSubscriptionScheduleEvent.bind(this),
        "subscription_schedule.canceled": this.handleSubscriptionScheduleEvent.bind(this),
        "subscription_schedule.completed": this.handleSubscriptionScheduleEvent.bind(this),
        "subscription_schedule.created": this.handleSubscriptionScheduleEvent.bind(this),
        "subscription_schedule.expiring": this.handleSubscriptionScheduleEvent.bind(this),
        "subscription_schedule.released": this.handleSubscriptionScheduleEvent.bind(this),
        "subscription_schedule.updated": this.handleSubscriptionScheduleEvent.bind(this),
        "payment_method.attached": this.handlePaymentMethodEvent.bind(this),
        "payment_method.automatically_updated": this.handlePaymentMethodEvent.bind(this),
        "payment_method.detached": this.handlePaymentMethodEvent.bind(this),
        "payment_method.updated": this.handlePaymentMethodEvent.bind(this),
        "charge.dispute.created": this.handleDisputeEvent.bind(this),
        "charge.dispute.funds_reinstated": this.handleDisputeEvent.bind(this),
        "charge.dispute.funds_withdrawn": this.handleDisputeEvent.bind(this),
        "charge.dispute.updated": this.handleDisputeEvent.bind(this),
        "charge.dispute.closed": this.handleDisputeEvent.bind(this),
        "payment_intent.amount_capturable_updated": this.handlePaymentIntentEvent.bind(this),
        "payment_intent.canceled": this.handlePaymentIntentEvent.bind(this),
        "payment_intent.created": this.handlePaymentIntentEvent.bind(this),
        "payment_intent.partially_funded": this.handlePaymentIntentEvent.bind(this),
        "payment_intent.payment_failed": this.handlePaymentIntentEvent.bind(this),
        "payment_intent.processing": this.handlePaymentIntentEvent.bind(this),
        "payment_intent.requires_action": this.handlePaymentIntentEvent.bind(this),
        "payment_intent.succeeded": this.handlePaymentIntentEvent.bind(this),
        "credit_note.created": this.handleCreditNoteEvent.bind(this),
        "credit_note.updated": this.handleCreditNoteEvent.bind(this),
        "credit_note.voided": this.handleCreditNoteEvent.bind(this),
        "radar.early_fraud_warning.created": this.handleEarlyFraudWarningEvent.bind(this),
        "radar.early_fraud_warning.updated": this.handleEarlyFraudWarningEvent.bind(this),
        "refund.created": this.handleRefundEvent.bind(this),
        "refund.failed": this.handleRefundEvent.bind(this),
        "refund.updated": this.handleRefundEvent.bind(this),
        "charge.refund.updated": this.handleRefundEvent.bind(this),
        "review.closed": this.handleReviewEvent.bind(this),
        "review.opened": this.handleReviewEvent.bind(this),
        "entitlements.active_entitlement_summary.updated": this.handleEntitlementSummaryEvent.bind(this)
    };
    async processEvent(event) {
        const objectAccountId = event.data?.object && typeof event.data.object === "object" && "account" in event.data.object ? event.data.object.account : void 0;
        const accountId = await this.getAccountId(objectAccountId);
        await this.getCurrentAccount();
        const handler = this.eventHandlers[event.type];
        if (handler) {
            const entityId = event.data?.object && typeof event.data.object === "object" && "id" in event.data.object ? event.data.object.id : "unknown";
            this.config.logger?.info(`Received webhook ${event.id}: ${event.type} for ${entityId}`);
            await handler(event, accountId);
        } else {
            this.config.logger?.warn(`Received unhandled webhook event: ${event.type} (${event.id}). Ignoring.`);
        }
    }
    /**
   * Returns an array of all webhook event types that this sync engine can handle.
   * Useful for configuring webhook endpoints with specific event subscriptions.
   */ getSupportedEventTypes() {
        return Object.keys(this.eventHandlers).sort();
    }
    // Event handler methods
    async handleChargeEvent(event, accountId) {
        const { entity: charge, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.charges.retrieve(id), (charge2)=>charge2.status === "failed" || charge2.status === "succeeded");
        await this.upsertCharges([
            charge
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleCustomerDeletedEvent(event, accountId) {
        const customer = {
            id: event.data.object.id,
            object: "customer",
            deleted: true
        };
        await this.upsertCustomers([
            customer
        ], accountId, this.getSyncTimestamp(event, false));
    }
    async handleCustomerEvent(event, accountId) {
        const { entity: customer, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.customers.retrieve(id), (customer2)=>customer2.deleted === true);
        await this.upsertCustomers([
            customer
        ], accountId, this.getSyncTimestamp(event, refetched));
    }
    async handleCheckoutSessionEvent(event, accountId) {
        const { entity: checkoutSession, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.checkout.sessions.retrieve(id));
        await this.upsertCheckoutSessions([
            checkoutSession
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleSubscriptionEvent(event, accountId) {
        const { entity: subscription, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.subscriptions.retrieve(id), (subscription2)=>subscription2.status === "canceled" || subscription2.status === "incomplete_expired");
        await this.upsertSubscriptions([
            subscription
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleTaxIdEvent(event, accountId) {
        const { entity: taxId, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.taxIds.retrieve(id));
        await this.upsertTaxIds([
            taxId
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleTaxIdDeletedEvent(event, _accountId) {
        const taxId = event.data.object;
        await this.deleteTaxId(taxId.id);
    }
    async handleInvoiceEvent(event, accountId) {
        const { entity: invoice, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.invoices.retrieve(id), (invoice2)=>invoice2.status === "void");
        await this.upsertInvoices([
            invoice
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleProductEvent(event, accountId) {
        try {
            const { entity: product, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.products.retrieve(id));
            await this.upsertProducts([
                product
            ], accountId, this.getSyncTimestamp(event, refetched));
        } catch (err) {
            if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeAPIError && err.code === "resource_missing") {
                const product = event.data.object;
                await this.deleteProduct(product.id);
            } else {
                throw err;
            }
        }
    }
    async handleProductDeletedEvent(event, _accountId) {
        const product = event.data.object;
        await this.deleteProduct(product.id);
    }
    async handlePriceEvent(event, accountId) {
        try {
            const { entity: price, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.prices.retrieve(id));
            await this.upsertPrices([
                price
            ], accountId, false, this.getSyncTimestamp(event, refetched));
        } catch (err) {
            if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeAPIError && err.code === "resource_missing") {
                const price = event.data.object;
                await this.deletePrice(price.id);
            } else {
                throw err;
            }
        }
    }
    async handlePriceDeletedEvent(event, _accountId) {
        const price = event.data.object;
        await this.deletePrice(price.id);
    }
    async handlePlanEvent(event, accountId) {
        try {
            const { entity: plan, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.plans.retrieve(id));
            await this.upsertPlans([
                plan
            ], accountId, false, this.getSyncTimestamp(event, refetched));
        } catch (err) {
            if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$stripe$40$20$2e$0$2e$0_$40$types$2b$node$40$22$2e$19$2e$8$2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].errors.StripeAPIError && err.code === "resource_missing") {
                const plan = event.data.object;
                await this.deletePlan(plan.id);
            } else {
                throw err;
            }
        }
    }
    async handlePlanDeletedEvent(event, _accountId) {
        const plan = event.data.object;
        await this.deletePlan(plan.id);
    }
    async handleSetupIntentEvent(event, accountId) {
        const { entity: setupIntent, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.setupIntents.retrieve(id), (setupIntent2)=>setupIntent2.status === "canceled" || setupIntent2.status === "succeeded");
        await this.upsertSetupIntents([
            setupIntent
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleSubscriptionScheduleEvent(event, accountId) {
        const { entity: subscriptionSchedule, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.subscriptionSchedules.retrieve(id), (schedule)=>schedule.status === "canceled" || schedule.status === "completed");
        await this.upsertSubscriptionSchedules([
            subscriptionSchedule
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handlePaymentMethodEvent(event, accountId) {
        const { entity: paymentMethod, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.paymentMethods.retrieve(id));
        await this.upsertPaymentMethods([
            paymentMethod
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleDisputeEvent(event, accountId) {
        const { entity: dispute, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.disputes.retrieve(id), (dispute2)=>dispute2.status === "won" || dispute2.status === "lost");
        await this.upsertDisputes([
            dispute
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handlePaymentIntentEvent(event, accountId) {
        const { entity: paymentIntent, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.paymentIntents.retrieve(id), // Final states - do not re-fetch from API
        (entity)=>entity.status === "canceled" || entity.status === "succeeded");
        await this.upsertPaymentIntents([
            paymentIntent
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleCreditNoteEvent(event, accountId) {
        const { entity: creditNote, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.creditNotes.retrieve(id), (creditNote2)=>creditNote2.status === "void");
        await this.upsertCreditNotes([
            creditNote
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleEarlyFraudWarningEvent(event, accountId) {
        const { entity: earlyFraudWarning, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.radar.earlyFraudWarnings.retrieve(id));
        await this.upsertEarlyFraudWarning([
            earlyFraudWarning
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleRefundEvent(event, accountId) {
        const { entity: refund, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.refunds.retrieve(id));
        await this.upsertRefunds([
            refund
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleReviewEvent(event, accountId) {
        const { entity: review, refetched } = await this.fetchOrUseWebhookData(event.data.object, (id)=>this.stripe.reviews.retrieve(id));
        await this.upsertReviews([
            review
        ], accountId, false, this.getSyncTimestamp(event, refetched));
    }
    async handleEntitlementSummaryEvent(event, accountId) {
        const activeEntitlementSummary = event.data.object;
        let entitlements = activeEntitlementSummary.entitlements;
        let refetched = false;
        if (this.config.revalidateObjectsViaStripeApi?.includes("entitlements")) {
            const { lastResponse, ...rest } = await this.stripe.entitlements.activeEntitlements.list({
                customer: activeEntitlementSummary.customer
            });
            entitlements = rest;
            refetched = true;
        }
        await this.deleteRemovedActiveEntitlements(activeEntitlementSummary.customer, entitlements.data.map((entitlement)=>entitlement.id));
        await this.upsertActiveEntitlements(activeEntitlementSummary.customer, entitlements.data, accountId, false, this.getSyncTimestamp(event, refetched));
    }
    getSyncTimestamp(event, refetched) {
        return refetched ? /* @__PURE__ */ new Date().toISOString() : new Date(event.created * 1e3).toISOString();
    }
    shouldRefetchEntity(entity) {
        return this.config.revalidateObjectsViaStripeApi?.includes(entity.object);
    }
    async fetchOrUseWebhookData(entity, fetchFn, entityInFinalState) {
        if (!entity.id) return {
            entity,
            refetched: false
        };
        if (entityInFinalState && entityInFinalState(entity)) return {
            entity,
            refetched: false
        };
        if (this.shouldRefetchEntity(entity)) {
            const fetchedEntity = await fetchFn(entity.id);
            return {
                entity: fetchedEntity,
                refetched: true
            };
        }
        return {
            entity,
            refetched: false
        };
    }
    async syncSingleEntity(stripeId) {
        const accountId = await this.getAccountId();
        if (stripeId.startsWith("cus_")) {
            return this.stripe.customers.retrieve(stripeId).then((it)=>{
                if (!it || it.deleted) return;
                return this.upsertCustomers([
                    it
                ], accountId);
            });
        } else if (stripeId.startsWith("in_")) {
            return this.stripe.invoices.retrieve(stripeId).then((it)=>this.upsertInvoices([
                    it
                ], accountId));
        } else if (stripeId.startsWith("price_")) {
            return this.stripe.prices.retrieve(stripeId).then((it)=>this.upsertPrices([
                    it
                ], accountId));
        } else if (stripeId.startsWith("prod_")) {
            return this.stripe.products.retrieve(stripeId).then((it)=>this.upsertProducts([
                    it
                ], accountId));
        } else if (stripeId.startsWith("sub_")) {
            return this.stripe.subscriptions.retrieve(stripeId).then((it)=>this.upsertSubscriptions([
                    it
                ], accountId));
        } else if (stripeId.startsWith("seti_")) {
            return this.stripe.setupIntents.retrieve(stripeId).then((it)=>this.upsertSetupIntents([
                    it
                ], accountId));
        } else if (stripeId.startsWith("pm_")) {
            return this.stripe.paymentMethods.retrieve(stripeId).then((it)=>this.upsertPaymentMethods([
                    it
                ], accountId));
        } else if (stripeId.startsWith("dp_") || stripeId.startsWith("du_")) {
            return this.stripe.disputes.retrieve(stripeId).then((it)=>this.upsertDisputes([
                    it
                ], accountId));
        } else if (stripeId.startsWith("ch_")) {
            return this.stripe.charges.retrieve(stripeId).then((it)=>this.upsertCharges([
                    it
                ], accountId, true));
        } else if (stripeId.startsWith("pi_")) {
            return this.stripe.paymentIntents.retrieve(stripeId).then((it)=>this.upsertPaymentIntents([
                    it
                ], accountId));
        } else if (stripeId.startsWith("txi_")) {
            return this.stripe.taxIds.retrieve(stripeId).then((it)=>this.upsertTaxIds([
                    it
                ], accountId));
        } else if (stripeId.startsWith("cn_")) {
            return this.stripe.creditNotes.retrieve(stripeId).then((it)=>this.upsertCreditNotes([
                    it
                ], accountId));
        } else if (stripeId.startsWith("issfr_")) {
            return this.stripe.radar.earlyFraudWarnings.retrieve(stripeId).then((it)=>this.upsertEarlyFraudWarning([
                    it
                ], accountId));
        } else if (stripeId.startsWith("prv_")) {
            return this.stripe.reviews.retrieve(stripeId).then((it)=>this.upsertReviews([
                    it
                ], accountId));
        } else if (stripeId.startsWith("re_")) {
            return this.stripe.refunds.retrieve(stripeId).then((it)=>this.upsertRefunds([
                    it
                ], accountId));
        } else if (stripeId.startsWith("feat_")) {
            return this.stripe.entitlements.features.retrieve(stripeId).then((it)=>this.upsertFeatures([
                    it
                ], accountId));
        } else if (stripeId.startsWith("cs_")) {
            return this.stripe.checkout.sessions.retrieve(stripeId).then((it)=>this.upsertCheckoutSessions([
                    it
                ], accountId));
        }
    }
    async syncBackfill(params) {
        const { object } = params ?? {
            object: this.getSupportedEventTypes
        };
        let products, prices, customers, checkoutSessions, subscriptions, subscriptionSchedules, invoices, setupIntents, paymentMethods, disputes, charges, paymentIntents, plans, taxIds, creditNotes, earlyFraudWarnings, refunds;
        await this.getCurrentAccount();
        switch(object){
            case "all":
                products = await this.syncProducts(params);
                prices = await this.syncPrices(params);
                plans = await this.syncPlans(params);
                customers = await this.syncCustomers(params);
                subscriptions = await this.syncSubscriptions(params);
                subscriptionSchedules = await this.syncSubscriptionSchedules(params);
                invoices = await this.syncInvoices(params);
                charges = await this.syncCharges(params);
                setupIntents = await this.syncSetupIntents(params);
                paymentMethods = await this.syncPaymentMethods(params);
                paymentIntents = await this.syncPaymentIntents(params);
                taxIds = await this.syncTaxIds(params);
                creditNotes = await this.syncCreditNotes(params);
                disputes = await this.syncDisputes(params);
                earlyFraudWarnings = await this.syncEarlyFraudWarnings(params);
                refunds = await this.syncRefunds(params);
                checkoutSessions = await this.syncCheckoutSessions(params);
                break;
            case "customer":
                customers = await this.syncCustomers(params);
                break;
            case "invoice":
                invoices = await this.syncInvoices(params);
                break;
            case "price":
                prices = await this.syncPrices(params);
                break;
            case "product":
                products = await this.syncProducts(params);
                break;
            case "subscription":
                subscriptions = await this.syncSubscriptions(params);
                break;
            case "subscription_schedules":
                subscriptionSchedules = await this.syncSubscriptionSchedules(params);
                break;
            case "setup_intent":
                setupIntents = await this.syncSetupIntents(params);
                break;
            case "payment_method":
                paymentMethods = await this.syncPaymentMethods(params);
                break;
            case "dispute":
                disputes = await this.syncDisputes(params);
                break;
            case "charge":
                charges = await this.syncCharges(params);
                break;
            case "payment_intent":
                paymentIntents = await this.syncPaymentIntents(params);
            case "plan":
                plans = await this.syncPlans(params);
                break;
            case "tax_id":
                taxIds = await this.syncTaxIds(params);
                break;
            case "credit_note":
                creditNotes = await this.syncCreditNotes(params);
                break;
            case "early_fraud_warning":
                earlyFraudWarnings = await this.syncEarlyFraudWarnings(params);
                break;
            case "refund":
                refunds = await this.syncRefunds(params);
                break;
            case "checkout_sessions":
                checkoutSessions = await this.syncCheckoutSessions(params);
                break;
            default:
                break;
        }
        return {
            products,
            prices,
            customers,
            checkoutSessions,
            subscriptions,
            subscriptionSchedules,
            invoices,
            setupIntents,
            paymentMethods,
            disputes,
            charges,
            paymentIntents,
            plans,
            taxIds,
            creditNotes,
            earlyFraudWarnings,
            refunds
        };
    }
    async syncProducts(syncParams) {
        this.config.logger?.info("Syncing products");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("products", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.products.list(params), (products)=>this.upsertProducts(products, accountId), accountId, "products");
    }
    async syncPrices(syncParams) {
        this.config.logger?.info("Syncing prices");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("prices", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.prices.list(params), (prices)=>this.upsertPrices(prices, accountId, syncParams?.backfillRelatedEntities), accountId, "prices");
    }
    async syncPlans(syncParams) {
        this.config.logger?.info("Syncing plans");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("plans", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.plans.list(params), (plans)=>this.upsertPlans(plans, accountId, syncParams?.backfillRelatedEntities), accountId, "plans");
    }
    async syncCustomers(syncParams) {
        this.config.logger?.info("Syncing customers");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("customers", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.customers.list(params), // @ts-expect-error
        (items)=>this.upsertCustomers(items, accountId), accountId, "customers");
    }
    async syncSubscriptions(syncParams) {
        this.config.logger?.info("Syncing subscriptions");
        const accountId = await this.getAccountId();
        const params = {
            status: "all",
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("subscriptions", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.subscriptions.list(params), (items)=>this.upsertSubscriptions(items, accountId, syncParams?.backfillRelatedEntities), accountId, "subscriptions");
    }
    async syncSubscriptionSchedules(syncParams) {
        this.config.logger?.info("Syncing subscription schedules");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("subscription_schedules", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.subscriptionSchedules.list(params), (items)=>this.upsertSubscriptionSchedules(items, accountId, syncParams?.backfillRelatedEntities), accountId, "subscription_schedules");
    }
    async syncInvoices(syncParams) {
        this.config.logger?.info("Syncing invoices");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("invoices", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.invoices.list(params), (items)=>this.upsertInvoices(items, accountId, syncParams?.backfillRelatedEntities), accountId, "invoices");
    }
    async syncCharges(syncParams) {
        this.config.logger?.info("Syncing charges");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("charges", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.charges.list(params), (items)=>this.upsertCharges(items, accountId, syncParams?.backfillRelatedEntities), accountId, "charges");
    }
    async syncSetupIntents(syncParams) {
        this.config.logger?.info("Syncing setup_intents");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("setup_intents", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.setupIntents.list(params), (items)=>this.upsertSetupIntents(items, accountId, syncParams?.backfillRelatedEntities), accountId, "setup_intents");
    }
    async syncPaymentIntents(syncParams) {
        this.config.logger?.info("Syncing payment_intents");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("payment_intents", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.paymentIntents.list(params), (items)=>this.upsertPaymentIntents(items, accountId, syncParams?.backfillRelatedEntities), accountId, "payment_intents");
    }
    async syncTaxIds(syncParams) {
        this.config.logger?.info("Syncing tax_ids");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        return this.fetchAndUpsert(()=>this.stripe.taxIds.list(params), (items)=>this.upsertTaxIds(items, accountId, syncParams?.backfillRelatedEntities), accountId);
    }
    async syncPaymentMethods(syncParams) {
        this.config.logger?.info("Syncing payment method");
        const accountId = await this.getAccountId();
        const prepared = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$yesql$40$7$2e$0$2e$0$2f$node_modules$2f$yesql$2f$yesql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pg"])(`select id from "stripe"."customers" WHERE COALESCE(deleted, false) <> true;`)([]);
        const customerIds = await this.postgresClient.query(prepared.text, prepared.values).then(({ rows })=>rows.map((it)=>it.id));
        this.config.logger?.info(`Getting payment methods for ${customerIds.length} customers`);
        let synced = 0;
        for (const customerIdChunk of chunkArray(customerIds, 10)){
            await Promise.all(customerIdChunk.map(async (customerId)=>{
                const syncResult = await this.fetchAndUpsert(()=>this.stripe.paymentMethods.list({
                        limit: 100,
                        customer: customerId
                    }), (items)=>this.upsertPaymentMethods(items, accountId, syncParams?.backfillRelatedEntities), accountId);
                synced += syncResult.synced;
            }));
        }
        return {
            synced
        };
    }
    async syncDisputes(syncParams) {
        this.config.logger?.info("Syncing disputes");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("disputes", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.disputes.list(params), (items)=>this.upsertDisputes(items, accountId, syncParams?.backfillRelatedEntities), accountId, "disputes");
    }
    async syncEarlyFraudWarnings(syncParams) {
        this.config.logger?.info("Syncing early fraud warnings");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("early_fraud_warnings", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.radar.earlyFraudWarnings.list(params), (items)=>this.upsertEarlyFraudWarning(items, accountId, syncParams?.backfillRelatedEntities), accountId, "early_fraud_warnings");
    }
    async syncRefunds(syncParams) {
        this.config.logger?.info("Syncing refunds");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("refunds", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.refunds.list(params), (items)=>this.upsertRefunds(items, accountId, syncParams?.backfillRelatedEntities), accountId, "refunds");
    }
    async syncCreditNotes(syncParams) {
        this.config.logger?.info("Syncing credit notes");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("credit_notes", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.creditNotes.list(params), (creditNotes)=>this.upsertCreditNotes(creditNotes, accountId), accountId, "credit_notes");
    }
    async syncFeatures(syncParams) {
        this.config.logger?.info("Syncing features");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100,
            ...syncParams?.pagination
        };
        return this.fetchAndUpsert(()=>this.stripe.entitlements.features.list(params), (features)=>this.upsertFeatures(features, accountId), accountId);
    }
    async syncEntitlements(customerId, syncParams) {
        this.config.logger?.info("Syncing entitlements");
        const accountId = await this.getAccountId();
        const params = {
            customer: customerId,
            limit: 100,
            ...syncParams?.pagination
        };
        return this.fetchAndUpsert(()=>this.stripe.entitlements.activeEntitlements.list(params), (entitlements)=>this.upsertActiveEntitlements(customerId, entitlements, accountId), accountId);
    }
    async syncCheckoutSessions(syncParams) {
        this.config.logger?.info("Syncing checkout sessions");
        const accountId = await this.getAccountId();
        const params = {
            limit: 100
        };
        if (syncParams?.created) {
            params.created = syncParams.created;
        } else {
            const cursor = await this.postgresClient.getSyncCursor("checkout_sessions", accountId);
            if (cursor) {
                params.created = {
                    gte: cursor
                };
                this.config.logger?.info(`Incremental sync from cursor: ${cursor}`);
            }
        }
        return this.fetchAndUpsert(()=>this.stripe.checkout.sessions.list(params), (items)=>this.upsertCheckoutSessions(items, accountId, syncParams?.backfillRelatedEntities), accountId, "checkout_sessions");
    }
    async fetchAndUpsert(fetch, upsert, accountId, resourceName) {
        const CHECKPOINT_SIZE = 100;
        let totalSynced = 0;
        let currentBatch = [];
        if (resourceName) {
            await this.postgresClient.markSyncRunning(resourceName, accountId);
        }
        try {
            this.config.logger?.info("Fetching items to sync from Stripe");
            try {
                for await (const item of fetch()){
                    currentBatch.push(item);
                    if (currentBatch.length >= CHECKPOINT_SIZE) {
                        this.config.logger?.info(`Upserting batch of ${currentBatch.length} items`);
                        await upsert(currentBatch, accountId);
                        totalSynced += currentBatch.length;
                        if (resourceName) {
                            const maxCreated = Math.max(...currentBatch.map((i)=>i.created || 0));
                            if (maxCreated > 0) {
                                await this.postgresClient.updateSyncCursor(resourceName, accountId, maxCreated);
                                this.config.logger?.info(`Checkpoint: cursor updated to ${maxCreated}`);
                            }
                        }
                        currentBatch = [];
                    }
                }
                if (currentBatch.length > 0) {
                    this.config.logger?.info(`Upserting final batch of ${currentBatch.length} items`);
                    await upsert(currentBatch, accountId);
                    totalSynced += currentBatch.length;
                    if (resourceName) {
                        const maxCreated = Math.max(...currentBatch.map((i)=>i.created || 0));
                        if (maxCreated > 0) {
                            await this.postgresClient.updateSyncCursor(resourceName, accountId, maxCreated);
                        }
                    }
                }
            } catch (error) {
                if (currentBatch.length > 0) {
                    this.config.logger?.info(`Error occurred, saving partial progress: ${currentBatch.length} items`);
                    await upsert(currentBatch, accountId);
                    totalSynced += currentBatch.length;
                    if (resourceName) {
                        const maxCreated = Math.max(...currentBatch.map((i)=>i.created || 0));
                        if (maxCreated > 0) {
                            await this.postgresClient.updateSyncCursor(resourceName, accountId, maxCreated);
                        }
                    }
                }
                throw error;
            }
            if (resourceName) {
                await this.postgresClient.markSyncComplete(resourceName, accountId);
            }
            this.config.logger?.info(`Sync complete: ${totalSynced} items synced`);
            return {
                synced: totalSynced
            };
        } catch (error) {
            if (resourceName) {
                await this.postgresClient.markSyncError(resourceName, accountId, error instanceof Error ? error.message : "Unknown error");
            }
            throw error;
        }
    }
    async upsertCharges(charges, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await Promise.all([
                this.backfillCustomers(getUniqueIds(charges, "customer"), accountId),
                this.backfillInvoices(getUniqueIds(charges, "invoice"), accountId)
            ]);
        }
        await this.expandEntity(charges, "refunds", (id)=>this.stripe.refunds.list({
                charge: id,
                limit: 100
            }));
        return this.postgresClient.upsertManyWithTimestampProtection(charges, "charges", accountId, syncTimestamp);
    }
    async backfillCharges(chargeIds, accountId) {
        const missingChargeIds = await this.postgresClient.findMissingEntries("charges", chargeIds);
        await this.fetchMissingEntities(missingChargeIds, (id)=>this.stripe.charges.retrieve(id)).then((charges)=>this.upsertCharges(charges, accountId));
    }
    async backfillPaymentIntents(paymentIntentIds, accountId) {
        const missingIds = await this.postgresClient.findMissingEntries("payment_intents", paymentIntentIds);
        await this.fetchMissingEntities(missingIds, (id)=>this.stripe.paymentIntents.retrieve(id)).then((paymentIntents)=>this.upsertPaymentIntents(paymentIntents, accountId));
    }
    async upsertCreditNotes(creditNotes, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await Promise.all([
                this.backfillCustomers(getUniqueIds(creditNotes, "customer"), accountId),
                this.backfillInvoices(getUniqueIds(creditNotes, "invoice"), accountId)
            ]);
        }
        await this.expandEntity(creditNotes, "lines", (id)=>this.stripe.creditNotes.listLineItems(id, {
                limit: 100
            }));
        return this.postgresClient.upsertManyWithTimestampProtection(creditNotes, "credit_notes", accountId, syncTimestamp);
    }
    async upsertCheckoutSessions(checkoutSessions, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await Promise.all([
                this.backfillCustomers(getUniqueIds(checkoutSessions, "customer"), accountId),
                this.backfillSubscriptions(getUniqueIds(checkoutSessions, "subscription"), accountId),
                this.backfillPaymentIntents(getUniqueIds(checkoutSessions, "payment_intent"), accountId),
                this.backfillInvoices(getUniqueIds(checkoutSessions, "invoice"), accountId)
            ]);
        }
        const rows = await this.postgresClient.upsertManyWithTimestampProtection(checkoutSessions, "checkout_sessions", accountId, syncTimestamp);
        await this.fillCheckoutSessionsLineItems(checkoutSessions.map((cs)=>cs.id), accountId, syncTimestamp);
        return rows;
    }
    async upsertEarlyFraudWarning(earlyFraudWarnings, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await Promise.all([
                this.backfillPaymentIntents(getUniqueIds(earlyFraudWarnings, "payment_intent"), accountId),
                this.backfillCharges(getUniqueIds(earlyFraudWarnings, "charge"), accountId)
            ]);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(earlyFraudWarnings, "early_fraud_warnings", accountId, syncTimestamp);
    }
    async upsertRefunds(refunds, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await Promise.all([
                this.backfillPaymentIntents(getUniqueIds(refunds, "payment_intent"), accountId),
                this.backfillCharges(getUniqueIds(refunds, "charge"), accountId)
            ]);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(refunds, "refunds", accountId, syncTimestamp);
    }
    async upsertReviews(reviews, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await Promise.all([
                this.backfillPaymentIntents(getUniqueIds(reviews, "payment_intent"), accountId),
                this.backfillCharges(getUniqueIds(reviews, "charge"), accountId)
            ]);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(reviews, "reviews", accountId, syncTimestamp);
    }
    async upsertCustomers(customers, accountId, syncTimestamp) {
        const deletedCustomers = customers.filter((customer)=>customer.deleted);
        const nonDeletedCustomers = customers.filter((customer)=>!customer.deleted);
        await this.postgresClient.upsertManyWithTimestampProtection(nonDeletedCustomers, "customers", accountId, syncTimestamp);
        await this.postgresClient.upsertManyWithTimestampProtection(deletedCustomers, "customers", accountId, syncTimestamp);
        return customers;
    }
    async backfillCustomers(customerIds, accountId) {
        const missingIds = await this.postgresClient.findMissingEntries("customers", customerIds);
        await this.fetchMissingEntities(missingIds, (id)=>this.stripe.customers.retrieve(id)).then((entries)=>this.upsertCustomers(entries, accountId)).catch((err)=>{
            this.config.logger?.error(err, "Failed to backfill");
            throw err;
        });
    }
    async upsertDisputes(disputes, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await this.backfillCharges(getUniqueIds(disputes, "charge"), accountId);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(disputes, "disputes", accountId, syncTimestamp);
    }
    async upsertInvoices(invoices, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await Promise.all([
                this.backfillCustomers(getUniqueIds(invoices, "customer"), accountId),
                this.backfillSubscriptions(getUniqueIds(invoices, "subscription"), accountId)
            ]);
        }
        await this.expandEntity(invoices, "lines", (id)=>this.stripe.invoices.listLineItems(id, {
                limit: 100
            }));
        return this.postgresClient.upsertManyWithTimestampProtection(invoices, "invoices", accountId, syncTimestamp);
    }
    backfillInvoices = async (invoiceIds, accountId)=>{
        const missingIds = await this.postgresClient.findMissingEntries("invoices", invoiceIds);
        await this.fetchMissingEntities(missingIds, (id)=>this.stripe.invoices.retrieve(id)).then((entries)=>this.upsertInvoices(entries, accountId));
    };
    backfillPrices = async (priceIds, accountId)=>{
        const missingIds = await this.postgresClient.findMissingEntries("prices", priceIds);
        await this.fetchMissingEntities(missingIds, (id)=>this.stripe.prices.retrieve(id)).then((entries)=>this.upsertPrices(entries, accountId));
    };
    async upsertPlans(plans, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await this.backfillProducts(getUniqueIds(plans, "product"), accountId);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(plans, "plans", accountId, syncTimestamp);
    }
    async deletePlan(id) {
        return this.postgresClient.delete("plans", id);
    }
    async upsertPrices(prices, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await this.backfillProducts(getUniqueIds(prices, "product"), accountId);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(prices, "prices", accountId, syncTimestamp);
    }
    async deletePrice(id) {
        return this.postgresClient.delete("prices", id);
    }
    async upsertProducts(products, accountId, syncTimestamp) {
        return this.postgresClient.upsertManyWithTimestampProtection(products, "products", accountId, syncTimestamp);
    }
    async deleteProduct(id) {
        return this.postgresClient.delete("products", id);
    }
    async backfillProducts(productIds, accountId) {
        const missingProductIds = await this.postgresClient.findMissingEntries("products", productIds);
        await this.fetchMissingEntities(missingProductIds, (id)=>this.stripe.products.retrieve(id)).then((products)=>this.upsertProducts(products, accountId));
    }
    async upsertPaymentIntents(paymentIntents, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await Promise.all([
                this.backfillCustomers(getUniqueIds(paymentIntents, "customer"), accountId),
                this.backfillInvoices(getUniqueIds(paymentIntents, "invoice"), accountId)
            ]);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(paymentIntents, "payment_intents", accountId, syncTimestamp);
    }
    async upsertPaymentMethods(paymentMethods, accountId, backfillRelatedEntities = false, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await this.backfillCustomers(getUniqueIds(paymentMethods, "customer"), accountId);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(paymentMethods, "payment_methods", accountId, syncTimestamp);
    }
    async upsertSetupIntents(setupIntents, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await this.backfillCustomers(getUniqueIds(setupIntents, "customer"), accountId);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(setupIntents, "setup_intents", accountId, syncTimestamp);
    }
    async upsertTaxIds(taxIds, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await this.backfillCustomers(getUniqueIds(taxIds, "customer"), accountId);
        }
        return this.postgresClient.upsertManyWithTimestampProtection(taxIds, "tax_ids", accountId, syncTimestamp);
    }
    async deleteTaxId(id) {
        return this.postgresClient.delete("tax_ids", id);
    }
    async upsertSubscriptionItems(subscriptionItems, accountId, syncTimestamp) {
        const modifiedSubscriptionItems = subscriptionItems.map((subscriptionItem)=>{
            const priceId = subscriptionItem.price.id.toString();
            const deleted = subscriptionItem.deleted;
            const quantity = subscriptionItem.quantity;
            return {
                ...subscriptionItem,
                price: priceId,
                deleted: deleted ?? false,
                quantity: quantity ?? null
            };
        });
        await this.postgresClient.upsertManyWithTimestampProtection(modifiedSubscriptionItems, "subscription_items", accountId, syncTimestamp);
    }
    async fillCheckoutSessionsLineItems(checkoutSessionIds, accountId, syncTimestamp) {
        for (const checkoutSessionId of checkoutSessionIds){
            const lineItemResponses = [];
            for await (const lineItem of this.stripe.checkout.sessions.listLineItems(checkoutSessionId, {
                limit: 100
            })){
                lineItemResponses.push(lineItem);
            }
            await this.upsertCheckoutSessionLineItems(lineItemResponses, checkoutSessionId, accountId, syncTimestamp);
        }
    }
    async upsertCheckoutSessionLineItems(lineItems, checkoutSessionId, accountId, syncTimestamp) {
        await this.backfillPrices(lineItems.map((lineItem)=>lineItem.price?.id?.toString() ?? void 0).filter((id)=>id !== void 0), accountId);
        const modifiedLineItems = lineItems.map((lineItem)=>{
            const priceId = typeof lineItem.price === "object" && lineItem.price?.id ? lineItem.price.id.toString() : lineItem.price?.toString() || null;
            return {
                ...lineItem,
                price: priceId,
                checkout_session: checkoutSessionId
            };
        });
        await this.postgresClient.upsertManyWithTimestampProtection(modifiedLineItems, "checkout_session_line_items", accountId, syncTimestamp);
    }
    async markDeletedSubscriptionItems(subscriptionId, currentSubItemIds) {
        let prepared = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$yesql$40$7$2e$0$2e$0$2f$node_modules$2f$yesql$2f$yesql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pg"])(`
    select id from "stripe"."subscription_items"
    where subscription = :subscriptionId and COALESCE(deleted, false) = false;
    `)({
            subscriptionId
        });
        const { rows } = await this.postgresClient.query(prepared.text, prepared.values);
        const deletedIds = rows.filter(({ id })=>currentSubItemIds.includes(id) === false);
        if (deletedIds.length > 0) {
            const ids = deletedIds.map(({ id })=>id);
            prepared = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$yesql$40$7$2e$0$2e$0$2f$node_modules$2f$yesql$2f$yesql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pg"])(`
      update "stripe"."subscription_items"
      set _raw_data = jsonb_set(_raw_data, '{deleted}', 'true'::jsonb)
      where id=any(:ids::text[]);
      `)({
                ids
            });
            const { rowCount } = await this.postgresClient.query(prepared.text, prepared.values);
            return {
                rowCount: rowCount || 0
            };
        } else {
            return {
                rowCount: 0
            };
        }
    }
    async upsertSubscriptionSchedules(subscriptionSchedules, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            const customerIds = getUniqueIds(subscriptionSchedules, "customer");
            await this.backfillCustomers(customerIds, accountId);
        }
        const rows = await this.postgresClient.upsertManyWithTimestampProtection(subscriptionSchedules, "subscription_schedules", accountId, syncTimestamp);
        return rows;
    }
    async upsertSubscriptions(subscriptions, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            const customerIds = getUniqueIds(subscriptions, "customer");
            await this.backfillCustomers(customerIds, accountId);
        }
        await this.expandEntity(subscriptions, "items", (id)=>this.stripe.subscriptionItems.list({
                subscription: id,
                limit: 100
            }));
        const rows = await this.postgresClient.upsertManyWithTimestampProtection(subscriptions, "subscriptions", accountId, syncTimestamp);
        const allSubscriptionItems = subscriptions.flatMap((subscription)=>subscription.items.data);
        await this.upsertSubscriptionItems(allSubscriptionItems, accountId, syncTimestamp);
        const markSubscriptionItemsDeleted = [];
        for (const subscription of subscriptions){
            const subscriptionItems = subscription.items.data;
            const subItemIds = subscriptionItems.map((x)=>x.id);
            markSubscriptionItemsDeleted.push(this.markDeletedSubscriptionItems(subscription.id, subItemIds));
        }
        await Promise.all(markSubscriptionItemsDeleted);
        return rows;
    }
    async deleteRemovedActiveEntitlements(customerId, currentActiveEntitlementIds) {
        const prepared = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$yesql$40$7$2e$0$2e$0$2f$node_modules$2f$yesql$2f$yesql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pg"])(`
      delete from "stripe"."active_entitlements"
      where customer = :customerId and id <> ALL(:currentActiveEntitlementIds::text[]);
      `)({
            customerId,
            currentActiveEntitlementIds
        });
        const { rowCount } = await this.postgresClient.query(prepared.text, prepared.values);
        return {
            rowCount: rowCount || 0
        };
    }
    async upsertFeatures(features, accountId, syncTimestamp) {
        return this.postgresClient.upsertManyWithTimestampProtection(features, "features", accountId, syncTimestamp);
    }
    async backfillFeatures(featureIds, accountId) {
        const missingFeatureIds = await this.postgresClient.findMissingEntries("features", featureIds);
        await this.fetchMissingEntities(missingFeatureIds, (id)=>this.stripe.entitlements.features.retrieve(id)).then((features)=>this.upsertFeatures(features, accountId)).catch((err)=>{
            this.config.logger?.error(err, "Failed to backfill features");
            throw err;
        });
    }
    async upsertActiveEntitlements(customerId, activeEntitlements, accountId, backfillRelatedEntities, syncTimestamp) {
        if (backfillRelatedEntities ?? this.config.backfillRelatedEntities) {
            await Promise.all([
                this.backfillCustomers(getUniqueIds(activeEntitlements, "customer"), accountId),
                this.backfillFeatures(getUniqueIds(activeEntitlements, "feature"), accountId)
            ]);
        }
        const entitlements = activeEntitlements.map((entitlement)=>({
                id: entitlement.id,
                object: entitlement.object,
                feature: typeof entitlement.feature === "string" ? entitlement.feature : entitlement.feature.id,
                customer: customerId,
                livemode: entitlement.livemode,
                lookup_key: entitlement.lookup_key
            }));
        return this.postgresClient.upsertManyWithTimestampProtection(entitlements, "active_entitlements", accountId, syncTimestamp);
    }
    async findOrCreateManagedWebhook(url, params) {
        const webhookParams = {
            enabled_events: this.getSupportedEventTypes(),
            ...params
        };
        const accountId = await this.getAccountId();
        const lockKey = `webhook:${accountId}:${url}`;
        return this.postgresClient.withAdvisoryLock(lockKey, async ()=>{
            const existingWebhook = await this.getManagedWebhookByUrl(url);
            if (existingWebhook) {
                try {
                    const stripeWebhook = await this.stripe.webhookEndpoints.retrieve(existingWebhook.id);
                    if (stripeWebhook.status === "enabled") {
                        return stripeWebhook;
                    }
                    this.config.logger?.info({
                        webhookId: existingWebhook.id
                    }, "Webhook is disabled, deleting and will recreate");
                    await this.stripe.webhookEndpoints.del(existingWebhook.id);
                    await this.postgresClient.delete("_managed_webhooks", existingWebhook.id);
                } catch (error) {
                    const stripeError = error;
                    if (stripeError?.statusCode === 404 || stripeError?.code === "resource_missing") {
                        this.config.logger?.warn({
                            error,
                            webhookId: existingWebhook.id
                        }, "Webhook not found in Stripe (404), removing from database");
                        await this.postgresClient.delete("_managed_webhooks", existingWebhook.id);
                    } else {
                        this.config.logger?.error({
                            error,
                            webhookId: existingWebhook.id
                        }, "Error retrieving webhook from Stripe, keeping in database");
                        throw error;
                    }
                }
            }
            const allDbWebhooks = await this.listManagedWebhooks();
            for (const dbWebhook of allDbWebhooks){
                if (dbWebhook.url !== url) {
                    this.config.logger?.info({
                        webhookId: dbWebhook.id,
                        oldUrl: dbWebhook.url,
                        newUrl: url
                    }, "Webhook URL mismatch, deleting");
                    try {
                        await this.stripe.webhookEndpoints.del(dbWebhook.id);
                    } catch (error) {
                        this.config.logger?.warn({
                            error,
                            webhookId: dbWebhook.id
                        }, "Failed to delete old webhook from Stripe");
                    }
                    await this.postgresClient.delete("_managed_webhooks", dbWebhook.id);
                }
            }
            try {
                const stripeWebhooks = await this.stripe.webhookEndpoints.list({
                    limit: 100
                });
                for (const stripeWebhook of stripeWebhooks.data){
                    const isManagedByMetadata = stripeWebhook.metadata?.managed_by?.toLowerCase().replace(/[\s\-]+/g, "") === "stripesync";
                    const normalizedDescription = stripeWebhook.description?.toLowerCase().replace(/[\s\-]+/g, "") || "";
                    const isManagedByDescription = normalizedDescription.includes("stripesync");
                    if (isManagedByMetadata || isManagedByDescription) {
                        const existsInDb = allDbWebhooks.some((dbWebhook)=>dbWebhook.id === stripeWebhook.id);
                        if (!existsInDb) {
                            this.config.logger?.warn({
                                webhookId: stripeWebhook.id,
                                url: stripeWebhook.url
                            }, "Found orphaned managed webhook in Stripe, deleting");
                            await this.stripe.webhookEndpoints.del(stripeWebhook.id);
                        }
                    }
                }
            } catch (error) {
                this.config.logger?.warn({
                    error
                }, "Failed to check for orphaned webhooks");
            }
            const webhook = await this.stripe.webhookEndpoints.create({
                ...webhookParams,
                url,
                // Always set metadata to identify managed webhooks
                metadata: {
                    ...webhookParams.metadata,
                    managed_by: "stripe-sync"
                }
            });
            const accountId2 = await this.getAccountId();
            await this.upsertManagedWebhooks([
                webhook
            ], accountId2);
            return webhook;
        });
    }
    async getManagedWebhook(id) {
        const accountId = await this.getAccountId();
        const result = await this.postgresClient.query(`SELECT * FROM "stripe"."_managed_webhooks" WHERE id = $1 AND "account_id" = $2`, [
            id,
            accountId
        ]);
        return result.rows.length > 0 ? result.rows[0] : null;
    }
    /**
   * Get a managed webhook by URL and account ID.
   * Used for race condition recovery: when createManagedWebhook hits a unique constraint
   * violation (another instance created the webhook), we need to fetch the existing webhook
   * by URL since we only know the URL, not the ID of the webhook that won the race.
   */ async getManagedWebhookByUrl(url) {
        const accountId = await this.getAccountId();
        const result = await this.postgresClient.query(`SELECT * FROM "stripe"."_managed_webhooks" WHERE url = $1 AND "account_id" = $2`, [
            url,
            accountId
        ]);
        return result.rows.length > 0 ? result.rows[0] : null;
    }
    async listManagedWebhooks() {
        const accountId = await this.getAccountId();
        const result = await this.postgresClient.query(`SELECT * FROM "stripe"."_managed_webhooks" WHERE "account_id" = $1 ORDER BY created DESC`, [
            accountId
        ]);
        return result.rows;
    }
    async updateManagedWebhook(id, params) {
        const webhook = await this.stripe.webhookEndpoints.update(id, params);
        const accountId = await this.getAccountId();
        await this.upsertManagedWebhooks([
            webhook
        ], accountId);
        return webhook;
    }
    async deleteManagedWebhook(id) {
        await this.stripe.webhookEndpoints.del(id);
        return this.postgresClient.delete("_managed_webhooks", id);
    }
    async upsertManagedWebhooks(webhooks, accountId, syncTimestamp) {
        const filteredWebhooks = webhooks.map((webhook)=>{
            const filtered = {};
            for (const prop of managedWebhookSchema.properties){
                if (prop in webhook) {
                    filtered[prop] = webhook[prop];
                }
            }
            return filtered;
        });
        return this.postgresClient.upsertManyWithTimestampProtection(filteredWebhooks, "_managed_webhooks", accountId, syncTimestamp);
    }
    async backfillSubscriptions(subscriptionIds, accountId) {
        const missingSubscriptionIds = await this.postgresClient.findMissingEntries("subscriptions", subscriptionIds);
        await this.fetchMissingEntities(missingSubscriptionIds, (id)=>this.stripe.subscriptions.retrieve(id)).then((subscriptions)=>this.upsertSubscriptions(subscriptions, accountId));
    }
    backfillSubscriptionSchedules = async (subscriptionIds, accountId)=>{
        const missingSubscriptionIds = await this.postgresClient.findMissingEntries("subscription_schedules", subscriptionIds);
        await this.fetchMissingEntities(missingSubscriptionIds, (id)=>this.stripe.subscriptionSchedules.retrieve(id)).then((subscriptionSchedules)=>this.upsertSubscriptionSchedules(subscriptionSchedules, accountId));
    };
    /**
   * Stripe only sends the first 10 entries by default, the option will actively fetch all entries.
   */ async expandEntity(entities, property, listFn) {
        if (!this.config.autoExpandLists) return;
        for (const entity of entities){
            if (entity[property]?.has_more) {
                const allData = [];
                for await (const fetchedEntity of listFn(entity.id)){
                    allData.push(fetchedEntity);
                }
                entity[property] = {
                    ...entity[property],
                    data: allData,
                    has_more: false
                };
            }
        }
    }
    async fetchMissingEntities(ids, fetch) {
        if (!ids.length) return [];
        const entities = [];
        for (const id of ids){
            const entity = await fetch(id);
            entities.push(entity);
        }
        return entities;
    }
};
function chunkArray(array, chunkSize) {
    const result = [];
    for(let i = 0; i < array.length; i += chunkSize){
        result.push(array.slice(i, i + chunkSize));
    }
    return result;
}
;
;
;
;
;
var __filename2 = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["fileURLToPath"])(__TURBOPACK__import$2e$meta__.url);
var __dirname2 = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(__filename2);
async function doesTableExist(client, schema, tableName) {
    const result = await client.query(`SELECT EXISTS (
      SELECT 1
      FROM information_schema.tables
      WHERE table_schema = $1
      AND table_name = $2
    )`, [
        schema,
        tableName
    ]);
    return result.rows[0]?.exists || false;
}
async function renameMigrationsTableIfNeeded(client, schema = "stripe", logger) {
    const oldTableExists = await doesTableExist(client, schema, "migrations");
    const newTableExists = await doesTableExist(client, schema, "_migrations");
    if (oldTableExists && !newTableExists) {
        logger?.info("Renaming migrations table to _migrations");
        await client.query(`ALTER TABLE "${schema}"."migrations" RENAME TO "_migrations"`);
        logger?.info("Successfully renamed migrations table");
    }
}
async function cleanupSchema(client, schema, logger) {
    logger?.warn(`Migrations table is empty - dropping and recreating schema "${schema}"`);
    await client.query(`DROP SCHEMA IF EXISTS "${schema}" CASCADE`);
    await client.query(`CREATE SCHEMA "${schema}"`);
    logger?.info(`Schema "${schema}" has been reset`);
}
async function connectAndMigrate(client, migrationsDirectory, config, logOnError = false) {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(migrationsDirectory)) {
        config.logger?.info(`Migrations directory ${migrationsDirectory} not found, skipping`);
        return;
    }
    const optionalConfig = {
        schemaName: "stripe",
        tableName: "_migrations"
    };
    try {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$2d$node$2d$migrations$40$0$2e$0$2e$8$2f$node_modules$2f$pg$2d$node$2d$migrations$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["migrate"])({
            client
        }, migrationsDirectory, optionalConfig);
    } catch (error) {
        if (logOnError && error instanceof Error) {
            config.logger?.error(error, "Migration error:");
        } else {
            throw error;
        }
    }
}
async function runMigrations(config) {
    const client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$pg$40$8$2e$18$2e$0$2f$node_modules$2f$pg$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Client"]({
        connectionString: config.databaseUrl,
        ssl: config.ssl,
        connectionTimeoutMillis: 1e4
    });
    const schema = "stripe";
    try {
        await client.connect();
        await client.query(`CREATE SCHEMA IF NOT EXISTS ${schema};`);
        await renameMigrationsTableIfNeeded(client, schema, config.logger);
        const tableExists = await doesTableExist(client, schema, "_migrations");
        if (tableExists) {
            const migrationCount = await client.query(`SELECT COUNT(*) as count FROM "${schema}"."_migrations"`);
            const isEmpty = migrationCount.rows[0]?.count === "0";
            if (isEmpty) {
                await cleanupSchema(client, schema, config.logger);
            }
        }
        config.logger?.info("Running migrations");
        await connectAndMigrate(client, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(__dirname2, "./migrations"), config);
    } catch (err) {
        config.logger?.error(err, "Error running migrations");
        throw err;
    } finally{
        await client.end();
        config.logger?.info("Finished migrations");
    }
}
;
}),
];

//# sourceMappingURL=node_modules__pnpm_595d401e._.js.map