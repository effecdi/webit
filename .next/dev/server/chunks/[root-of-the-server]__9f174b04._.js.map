{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/stripe-client.ts"],"sourcesContent":["import Stripe from 'stripe';\n\nasync function getCredentials() {\n  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME;\n  const xReplitToken = process.env.REPL_IDENTITY\n    ? 'repl ' + process.env.REPL_IDENTITY\n    : process.env.WEB_REPL_RENEWAL\n      ? 'depl ' + process.env.WEB_REPL_RENEWAL\n      : null;\n\n  if (!xReplitToken) {\n    throw new Error('X_REPLIT_TOKEN not found for repl/depl');\n  }\n\n  const connectorName = 'stripe';\n  const isProduction = process.env.REPLIT_DEPLOYMENT === '1';\n  const targetEnvironment = isProduction ? 'production' : 'development';\n\n  const url = new URL(`https://${hostname}/api/v2/connection`);\n  url.searchParams.set('include_secrets', 'true');\n  url.searchParams.set('connector_names', connectorName);\n  url.searchParams.set('environment', targetEnvironment);\n\n  const response = await fetch(url.toString(), {\n    headers: {\n      'Accept': 'application/json',\n      'X_REPLIT_TOKEN': xReplitToken\n    }\n  });\n\n  const data = await response.json();\n  const connectionSettings = data.items?.[0];\n\n  if (!connectionSettings || (!connectionSettings.settings.publishable || !connectionSettings.settings.secret)) {\n    throw new Error(`Stripe ${targetEnvironment} connection not found`);\n  }\n\n  return {\n    publishableKey: connectionSettings.settings.publishable,\n    secretKey: connectionSettings.settings.secret,\n  };\n}\n\nexport async function getUncachableStripeClient() {\n  const { secretKey } = await getCredentials();\n  return new Stripe(secretKey, {\n    apiVersion: '2025-08-27.basil' as any,\n  });\n}\n\nexport async function getStripePublishableKey() {\n  const { publishableKey } = await getCredentials();\n  return publishableKey;\n}\n\nexport async function getStripeSecretKey() {\n  const { secretKey } = await getCredentials();\n  return secretKey;\n}\n\nlet stripeSync: any = null;\n\nexport async function getStripeSync() {\n  if (!stripeSync) {\n    const { StripeSync } = await import('stripe-replit-sync');\n    const secretKey = await getStripeSecretKey();\n\n    stripeSync = new StripeSync({\n      poolConfig: {\n        connectionString: process.env.DATABASE_URL!,\n        max: 2,\n      },\n      stripeSecretKey: secretKey,\n    });\n  }\n  return stripeSync;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA,eAAe;IACb,MAAM,WAAW,QAAQ,GAAG,CAAC,0BAA0B;IACvD,MAAM,eAAe,QAAQ,GAAG,CAAC,aAAa,GAC1C,UAAU,QAAQ,GAAG,CAAC,aAAa,GACnC,QAAQ,GAAG,CAAC,gBAAgB,GAC1B,UAAU,QAAQ,GAAG,CAAC,gBAAgB,GACtC;IAEN,IAAI,CAAC,cAAc;QACjB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,gBAAgB;IACtB,MAAM,eAAe,QAAQ,GAAG,CAAC,iBAAiB,KAAK;IACvD,MAAM,oBAAoB,eAAe,eAAe;IAExD,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE,SAAS,kBAAkB,CAAC;IAC3D,IAAI,YAAY,CAAC,GAAG,CAAC,mBAAmB;IACxC,IAAI,YAAY,CAAC,GAAG,CAAC,mBAAmB;IACxC,IAAI,YAAY,CAAC,GAAG,CAAC,eAAe;IAEpC,MAAM,WAAW,MAAM,MAAM,IAAI,QAAQ,IAAI;QAC3C,SAAS;YACP,UAAU;YACV,kBAAkB;QACpB;IACF;IAEA,MAAM,OAAO,MAAM,SAAS,IAAI;IAChC,MAAM,qBAAqB,KAAK,KAAK,EAAE,CAAC,EAAE;IAE1C,IAAI,CAAC,sBAAuB,CAAC,mBAAmB,QAAQ,CAAC,WAAW,IAAI,CAAC,mBAAmB,QAAQ,CAAC,MAAM,EAAG;QAC5G,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,kBAAkB,qBAAqB,CAAC;IACpE;IAEA,OAAO;QACL,gBAAgB,mBAAmB,QAAQ,CAAC,WAAW;QACvD,WAAW,mBAAmB,QAAQ,CAAC,MAAM;IAC/C;AACF;AAEO,eAAe;IACpB,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM;IAC5B,OAAO,IAAI,0PAAM,CAAC,WAAW;QAC3B,YAAY;IACd;AACF;AAEO,eAAe;IACpB,MAAM,EAAE,cAAc,EAAE,GAAG,MAAM;IACjC,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM;IAC5B,OAAO;AACT;AAEA,IAAI,aAAkB;AAEf,eAAe;IACpB,IAAI,CAAC,YAAY;QACf,MAAM,EAAE,UAAU,EAAE,GAAG;QACvB,MAAM,YAAY,MAAM;QAExB,aAAa,IAAI,WAAW;YAC1B,YAAY;gBACV,kBAAkB,QAAQ,GAAG,CAAC,YAAY;gBAC1C,KAAK;YACP;YACA,iBAAiB;QACnB;IACF;IACA,OAAO;AACT"}},
    {"offset": {"line": 204, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/lib/stripe-init.ts"],"sourcesContent":["import { runMigrations } from 'stripe-replit-sync';\nimport { getStripeSync } from '@/lib/stripe-client';\n\nlet initialized = false;\nlet initPromise: Promise<void> | null = null;\n\nexport async function ensureStripeInitialized() {\n  if (initialized) return;\n  if (initPromise) return initPromise;\n\n  initPromise = (async () => {\n    const databaseUrl = process.env.DATABASE_URL;\n    if (!databaseUrl) {\n      console.error('DATABASE_URL not set, skipping Stripe init');\n      return;\n    }\n\n    try {\n      console.log('Initializing Stripe schema...');\n      await runMigrations({ databaseUrl });\n      console.log('Stripe schema ready');\n\n      const stripeSync = await getStripeSync();\n\n      const domain = process.env.REPLIT_DOMAINS?.split(',')[0] || process.env.REPLIT_DEV_DOMAIN;\n      if (domain) {\n        try {\n          console.log('Setting up managed webhook...');\n          const result = await stripeSync.findOrCreateManagedWebhook(\n            `https://${domain}/api/stripe/webhook`\n          );\n          console.log('Webhook setup result:', JSON.stringify(result, null, 2).substring(0, 200));\n        } catch (webhookErr: any) {\n          console.warn('Webhook setup warning (non-fatal):', webhookErr.message);\n        }\n      }\n\n      stripeSync.syncBackfill()\n        .then(() => console.log('Stripe data synced'))\n        .catch((err: any) => console.error('Error syncing Stripe data:', err));\n\n      initialized = true;\n    } catch (error) {\n      console.error('Failed to initialize Stripe:', error);\n      initPromise = null;\n    }\n  })();\n\n  return initPromise;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,IAAI,cAAc;AAClB,IAAI,cAAoC;AAEjC,eAAe;IACpB,IAAI,aAAa;IACjB,IAAI,aAAa,OAAO;IAExB,cAAc,CAAC;QACb,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;QAC5C,IAAI,CAAC,aAAa;YAChB,QAAQ,KAAK,CAAC;YACd;QACF;QAEA,IAAI;YACF,QAAQ,GAAG,CAAC;YACZ,MAAM,IAAA,4SAAa,EAAC;gBAAE;YAAY;YAClC,QAAQ,GAAG,CAAC;YAEZ,MAAM,aAAa,MAAM,IAAA,0IAAa;YAEtC,MAAM,SAAS,QAAQ,GAAG,CAAC,cAAc,EAAE,MAAM,IAAI,CAAC,EAAE,IAAI,QAAQ,GAAG,CAAC,iBAAiB;YACzF,IAAI,QAAQ;gBACV,IAAI;oBACF,QAAQ,GAAG,CAAC;oBACZ,MAAM,SAAS,MAAM,WAAW,0BAA0B,CACxD,CAAC,QAAQ,EAAE,OAAO,mBAAmB,CAAC;oBAExC,QAAQ,GAAG,CAAC,yBAAyB,KAAK,SAAS,CAAC,QAAQ,MAAM,GAAG,SAAS,CAAC,GAAG;gBACpF,EAAE,OAAO,YAAiB;oBACxB,QAAQ,IAAI,CAAC,sCAAsC,WAAW,OAAO;gBACvE;YACF;YAEA,WAAW,YAAY,GACpB,IAAI,CAAC,IAAM,QAAQ,GAAG,CAAC,uBACvB,KAAK,CAAC,CAAC,MAAa,QAAQ,KAAK,CAAC,8BAA8B;YAEnE,cAAc;QAChB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,cAAc;QAChB;IACF,CAAC;IAED,OAAO;AACT"}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/app/api/stripe/webhook/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getStripeSync } from '@/lib/stripe-client';\nimport { ensureStripeInitialized } from '@/lib/stripe-init';\n\nexport async function POST(request: NextRequest) {\n  try {\n    await ensureStripeInitialized();\n\n    const signature = request.headers.get('stripe-signature');\n    if (!signature) {\n      return NextResponse.json({ error: 'Missing stripe-signature' }, { status: 400 });\n    }\n\n    const body = await request.arrayBuffer();\n    const payload = Buffer.from(body);\n\n    const sync = await getStripeSync();\n    await sync.processWebhook(payload, signature);\n\n    return NextResponse.json({ received: true });\n  } catch (error: any) {\n    console.error('Webhook error:', error.message);\n    return NextResponse.json({ error: 'Webhook processing error' }, { status: 400 });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,IAAA,kJAAuB;QAE7B,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC;QACtC,IAAI,CAAC,WAAW;YACd,OAAO,gRAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA2B,GAAG;gBAAE,QAAQ;YAAI;QAChF;QAEA,MAAM,OAAO,MAAM,QAAQ,WAAW;QACtC,MAAM,UAAU,OAAO,IAAI,CAAC;QAE5B,MAAM,OAAO,MAAM,IAAA,0IAAa;QAChC,MAAM,KAAK,cAAc,CAAC,SAAS;QAEnC,OAAO,gRAAY,CAAC,IAAI,CAAC;YAAE,UAAU;QAAK;IAC5C,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,kBAAkB,MAAM,OAAO;QAC7C,OAAO,gRAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA2B,GAAG;YAAE,QAAQ;QAAI;IAChF;AACF"}}]
}